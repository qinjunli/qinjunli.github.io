<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>从源码角度剖析Fragment核心知识点 | Hexo</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">从源码角度剖析Fragment核心知识点</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">从源码角度剖析Fragment核心知识点</h1><div class="post-meta">Sep 6, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/09/06/deep-into-android-fragment/" href="/2016/09/06/deep-into-android-fragment/#comments" class="ds-thread-count"></a><div class="post-content"><p>自动Android在3.0版本中推出Fragment以来，fragment在我们日常的开发中无处不在，他使我们的在开发android时能更好的做到view的解耦。关于Fragment的用法，相信大家已经用的滚瓜烂熟了，各种FragmentTransaction的操作，都信手拈来。今天我们要从源码的角度去剖析fragment内部实现的原理，我相信只有了解了内部实现原理，我们在碰到fragment的issue的时候才知道如何去解决。</p>
<p>我们今天要分析的是support v4包中的Fragment，相信绝大部分人都是用的兼容包中的fragment。</p>
<p>先上一张图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1008428-b84d45b1ba19d73d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fragment有关类结构图"></p>
<p>这张图描述的是与fragment相关的类的UML图，基本描述了这些类之间的关系。<br>Fragment理论上可以被任何对象持有，然后管理其生命周期，但是绝大部分时候，我们都是在activity里面使用它，我们可以从Activity出发，理清楚这些类之间的关系。</p>
<p>###FragmentActivity<br>兼容包中，支持fragment的activity叫做FragmentActivity, 我们常用的AppCompatActivity也是继承自它，</p>
<p>在FragmentActivity中有一个重要的成员变量mFragments，它的类型是FragmentController<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final FragmentController mFragments = FragmentController.createController(new HostCallbacks());</div></pre></td></tr></table></figure></p>
<p>正是这个mFragments的存在使得在FragmentActivity中进行fragment操作成为可能，我们可以看到在FragmentActivity中进行的任何fragment的操作都得经FragmentController之手</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> @Override</div><div class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">    mFragments.attachHost(null /*parent*/);</div><div class="line"></div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">    //...</div><div class="line">    mFragments.restoreAllState(p, nc != null ? nc.fragments : null);</div><div class="line"></div><div class="line">    //...</div><div class="line">    mFragments.dispatchCreate();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public FragmentManager getSupportFragmentManager() &#123;</div><div class="line">        return mFragments.getSupportFragmentManager();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，我们进到<strong>FragmentController</strong>类中去一探究竟。打开FragmentController,发现其函数实现非常简单。基本上你可以认为FragmentController是FragmentManager的代理，Activity需要的FragmentController的函数，最后调用的都是FragmentHostCallback中的FragmentManager的方法。</p>
<p><strong>FragmentHostCallback</strong>，我们可以认为他是用来<strong>管理Fragment生命周期</strong>，同时作为<strong>代理</strong>提供fragment需要与外界打交道时的函数实现的比如从fragment中启动新的Activity, 请求权限等等。其Fragment生命周期的的管理由FragmentManager负责，其余部分代理功能由其自己负责。</p>
<p>我们打开FragmentHostCallback的源代码，可以看到其头顶注释中写着：fragment可以被任何对象持有，要使一个对象具有持有和管理fragment生命周期的能力，我们只需要实现FragmentHostCallback中的函数。显然，我们最常见的FragmentActivity肯定实现了FragmentHostCallback，我们跳转到FragmentActivity，看到其内部有一个非静态内部类HostCallbacks, 正式这个内部类的存在，使得FragmentActivity具有了持有和管理Fragment的能力，Fragment与外部交互的功能都由FragmentActivity实现了。至于FragmentController，前面已经说到，只是作为中间桥梁的作用。</p>
<p>###Fragment<br>前面讲了这么多，我们还没有开始介绍今天的主角Fragment， 接下来我们就来揭开其稍许神秘的面纱。</p>
<p>Fragment = Attr  + View + + State， 此处等待UML图</p>
<p>####Attr<br><strong>Attr</strong>指得是Fragment的一些固有属性，不会随着Fragment的生命周期发生变化的，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bundle mArguments;  //构造参数</div><div class="line">boolean mFromLayout; //是否从layout文件中创建</div><div class="line">...</div></pre></td></tr></table></figure>
<p>####View</p>
<p><strong>View</strong>是Fragment创建出来并显示给用户的界面的view，如果Fragment被持有，会被添加到Activity某一块layout中去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// The parent container of the fragment after dynamically added to UI.</div><div class="line">ViewGroup mContainer;</div><div class="line"></div><div class="line">// The View generated for this fragment.</div><div class="line">View mView;</div><div class="line"></div><div class="line">// The real inner view that will save/restore state.</div><div class="line">View mInnerView;</div></pre></td></tr></table></figure>
<p>####State</p>
<p><strong>State</strong>指的是Fragment在生命周期变迁中中会发生改变的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int mState = INITIALIZING; //生命周期状态</div><div class="line">boolean mAdded; //是否被添加</div><div class="line">boolean mRemoving; //是否被移除</div><div class="line">boolean mHidden;// 是否被隐藏</div><div class="line">boolean mDetached; //是否已经分离</div><div class="line">...</div></pre></td></tr></table></figure>
<p>其中Fragment的成员变量mState，直接映射了Fragment的生命周期状态变迁，其取值状态在以下常量中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static final int INITIALIZING = 0;     // Not yet created.</div><div class="line">static final int CREATED = 1;          // Created.</div><div class="line">static final int ACTIVITY_CREATED = 2; // The activity has finished its creation.</div><div class="line">static final int STOPPED = 3;          // Fully created, not started.</div><div class="line">static final int STARTED = 4;          // Created and started, not resumed.</div><div class="line">static final int RESUMED = 5;          // Created started and resumed.</div></pre></td></tr></table></figure>
<p>我们在开中经常重写的onCreate, onResume, onStop方法都发生mState的变迁过程中。 接下来，我们就来看看Fragment的生命周期是如何变化的。</p>
<p>###Fragment事务操作：BackStackRecord</p>
<p>我们在开发中，每次要操作那个Fragment的添加，删除，隐藏，显示等，都需要使用FragmentTransaction，比如添加一个Fragment：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();</div><div class="line">transaction.add(R.id.contaniner, testFragment);</div><div class="line">transaction.commit();</div></pre></td></tr></table></figure>
<p>FragmentTransaction实际上是一个抽象类，里面定义了一些关于Fragment操作的函数接口，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public abstract class FragmentTransaction &#123;</div><div class="line"></div><div class="line">	add</div><div class="line"></div><div class="line">	replace</div><div class="line"></div><div class="line">	remove</div><div class="line"></div><div class="line">	hide </div><div class="line"></div><div class="line">	show</div><div class="line"></div><div class="line">	detach</div><div class="line"></div><div class="line">	attach</div><div class="line"></div><div class="line">	addToBackStack</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从FragmentManger.beginTransaction真正返回的确是一个<strong>BackStackRecord</strong>类， 其实现了FragmentTransaction所定义的接口。</p>
<p>接下来，我们以添加为例，看看BackStackRecord是如何完成Add这个transaction的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123;</div><div class="line">    fragment.mFragmentManager = mManager;</div><div class="line"></div><div class="line">    if (tag != null) &#123;</div><div class="line">        if (fragment.mTag != null &amp;&amp; !tag.equals(fragment.mTag)) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Can&apos;t change tag of fragment &quot;</div><div class="line">                    + fragment + &quot;: was &quot; + fragment.mTag</div><div class="line">                    + &quot; now &quot; + tag);</div><div class="line">        &#125;</div><div class="line">        fragment.mTag = tag;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (containerViewId != 0) &#123;</div><div class="line">        if (fragment.mFragmentId != 0 &amp;&amp; fragment.mFragmentId != containerViewId) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Can&apos;t change container ID of fragment &quot;</div><div class="line">                    + fragment + &quot;: was &quot; + fragment.mFragmentId</div><div class="line">                    + &quot; now &quot; + containerViewId);</div><div class="line">        &#125;</div><div class="line">        fragment.mContainerId = fragment.mFragmentId = containerViewId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Op op = new Op();</div><div class="line">    op.cmd = opcmd;</div><div class="line">    op.fragment = fragment;</div><div class="line">    addOp(op);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BackStackRecord中实现的四个add函数，最后都调用了doAddOp，我们注意到已经添加过的Fragment其tag和被添加到的containerId是不能更改的，否则会抛异常。 函数最后new了一个Op，Op是啥？Op其实就是Operation的简称，有经验的读者应该知道在<strong>一次FragmentTransaction中实际上可以进行多次add，remove之类的操作。每次操作，都会生成一个新的Op对象，在transaction commit操作时，会将这些Operation全部执行掉</strong>。</p>
<p>我们来看看Op类对象里都有些啥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static final class Op &#123;</div><div class="line">    Op next;</div><div class="line">    Op prev;</div><div class="line">    int cmd;</div><div class="line">    Fragment fragment;</div><div class="line">    int enterAnim;</div><div class="line">    int exitAnim;</div><div class="line">    int popEnterAnim;</div><div class="line">    int popExitAnim;</div><div class="line">    ArrayList&lt;Fragment&gt; removed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从next， prev 两个指针可以看出，Op是作为一个链表的节点而存在的，因此FragmentTransaction肯定是在一个链表中存储了一次事务中的所有需要执行的操作。</p>
<p>cmd定义了Operation操作的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static final int OP_NULL = 0;</div><div class="line">static final int OP_ADD = 1;</div><div class="line">static final int OP_REPLACE = 2;</div><div class="line">static final int OP_REMOVE = 3;</div><div class="line">static final int OP_HIDE = 4;</div><div class="line">static final int OP_SHOW = 5;</div><div class="line">static final int OP_DETACH = 6;</div><div class="line">static final int OP_ATTACH = 7;</div></pre></td></tr></table></figure></p>
<p>fragment指定了这次Operation要操纵哪一个Fragment<br>此外Op类还包含了转场动画和一个操作会移除的Fragment集合。</p>
<p>doAddOp函数最后执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void addOp(Op op) &#123;</div><div class="line">    if (mHead == null) &#123;</div><div class="line">        mHead = mTail = op;</div><div class="line">    &#125; else &#123;</div><div class="line">        op.prev = mTail;</div><div class="line">        mTail.next = op;</div><div class="line">        mTail = op;</div><div class="line">    &#125;</div><div class="line">    op.enterAnim = mEnterAnim;</div><div class="line">    op.exitAnim = mExitAnim;</div><div class="line">    op.popEnterAnim = mPopEnterAnim;</div><div class="line">    op.popExitAnim = mPopExitAnim;</div><div class="line">    mNumOp++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>addOp执行了一个典型的添加节点到链表末尾的数据结构操作，并将transaction的动画赋给op，最后讲mNumOp加一，mNumOp代表了这次transaction中包含的操作个数。如果为0，则<strong>isEmpty</strong>返回true.</p>
<p>等到操作都添加好了之后，就差commit了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int commitInternal(boolean allowStateLoss) &#123;</div><div class="line">    if (mCommitted) throw new IllegalStateException(&quot;commit already called&quot;);</div><div class="line">    if (FragmentManagerImpl.DEBUG) &#123;</div><div class="line">        Log.v(TAG, &quot;Commit: &quot; + this);</div><div class="line">        LogWriter logw = new LogWriter(TAG);</div><div class="line">        PrintWriter pw = new PrintWriter(logw);</div><div class="line">        dump(&quot;  &quot;, null, pw, null);</div><div class="line">    &#125;</div><div class="line">    mCommitted = true;</div><div class="line">    if (mAddToBackStack) &#123;</div><div class="line">        //添加到返回栈</div><div class="line">        mIndex = mManager.allocBackStackIndex(this);</div><div class="line">    &#125; else &#123;</div><div class="line">        mIndex = -1;</div><div class="line">    &#125;</div><div class="line">    mManager.enqueueAction(this, allowStateLoss);</div><div class="line">    return mIndex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果设置了addToBackStack，就会执行添加到返回栈的操作，这个我们后面会专门讲，mManager.enqueueAction 顾名思义就是讲当前的transaction操做入队列，因此在FragmentManager肯定会维护一个队列来存储当前尚未执行的transaction.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void enqueueAction(Runnable action, boolean allowStateLoss) &#123;</div><div class="line">    ...</div><div class="line">    synchronized (this) &#123;</div><div class="line">        ...</div><div class="line">    </div><div class="line">        mPendingActions.add(action);</div><div class="line">        if (mPendingActions.size() == 1) &#123;</div><div class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</div><div class="line">            mHost.getHandler().post(mExecCommit);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>enqueueAction首先会将action，添加到一个叫mPendingAction的列表中去，这个列表中存储着一堆Runnable对象，代表着还未执行的事务，稍等一会儿，我们刚刚说到的是BackStackRecord类对吧，怎么可以添加到Runnable列表中呢，原来BackStackRecod本身还是实现了Runnabled接口，是一个可以执行的对象。添加完毕之后，会调用FragmentHostCallback中提供的getHandler方法，获取到Handler方法，然后向主线程的MessageQueue中发送一个mExecCommit可执行对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"> Runnable mExecCommit = new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            execPendingActions();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">public boolean execPendingActions() &#123;</div><div class="line"></div><div class="line">    boolean didSomething = false;</div><div class="line"></div><div class="line">    while (true) &#123;</div><div class="line">        int numActions;</div><div class="line">        </div><div class="line">        synchronized (this) &#123;</div><div class="line">            if (mPendingActions == null || mPendingActions.size() == 0) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            numActions = mPendingActions.size();</div><div class="line">            if (mTmpActions == null || mTmpActions.length &lt; numActions) &#123;</div><div class="line">                mTmpActions = new Runnable[numActions];</div><div class="line">            &#125;</div><div class="line">            //讲mPendingAction中的对象转移到mTmpActions</div><div class="line">            mPendingActions.toArray(mTmpActions);</div><div class="line">            mPendingActions.clear();</div><div class="line">            mHost.getHandler().removeCallbacks(mExecCommit);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //遍历mTmpActions，执行run</div><div class="line">        mExecutingActions = true;</div><div class="line">        for (int i=0; i&lt;numActions; i++) &#123;</div><div class="line">            mTmpActions[i].run();</div><div class="line">            mTmpActions[i] = null;</div><div class="line">        &#125;</div><div class="line">        mExecutingActions = false;</div><div class="line">        didSomething = true;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    return didSomething;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此绕来绕去，最后调用的BackStackRecord本身的run方法，这也符合了commit方法名字本身的定义，transaction只是被批量提交到了主线程的任务队列里，并不是马上执行，等待主线程的looper去安排这些任务的执行。</p>
<p>那好，我们现在回家吧，去看看BackStackRecord。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    Op op = mHead;</div><div class="line">    while (op != null) &#123;</div><div class="line">        int enterAnim = state != null ? 0 : op.enterAnim;</div><div class="line">        int exitAnim = state != null ? 0 : op.exitAnim;</div><div class="line">        switch (op.cmd) &#123;</div><div class="line">            case OP_ADD: &#123;</div><div class="line">                Fragment f = op.fragment;</div><div class="line">                f.mNextAnim = enterAnim;</div><div class="line">                mManager.addFragment(f, false);</div><div class="line">            &#125; break;</div><div class="line">            case OP_REPLACE: &#123;</div><div class="line">                  ... </div><div class="line">            &#125; break;</div><div class="line">            case OP_REMOVE: &#123;</div><div class="line">                Fragment f = op.fragment;</div><div class="line">                f.mNextAnim = exitAnim;</div><div class="line">                mManager.removeFragment(f, transition, transitionStyle);</div><div class="line">            &#125; break;</div><div class="line">            case OP_HIDE: &#123;</div><div class="line">                ...</div><div class="line">            &#125; break;</div><div class="line">            ...</div><div class="line">            //更多case</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        op = op.next;</div><div class="line">    &#125;</div><div class="line">    //将active状态的fragment全部执行状态变迁检查</div><div class="line">    mManager.moveToState(mManager.mCurState, transition, transitionStyle, true);</div><div class="line"></div><div class="line">    if (mAddToBackStack) &#123;</div><div class="line">        mManager.addBackStackState(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>run方法内部根据不同的cmd走了很不不同的分支，每个分支内部都会对，fragment状态做改变，最后调用moveToState将fragment的生命周期状态mState进行变迁。</p>
<p>当然我们注意到hide和show，它们内部实际上不会调用调用moveToState, 因为hideFragment实际上就做了三件事请，</p>
<ul>
<li>设置mHidden 为true</li>
<li>fragment.mView.setVisibility(View.GONE); 隐藏fragment的view</li>
<li>fragment.onHiddenChanged(true); 调用onHiddenChange</li>
</ul>
<p>showFragment也是类似，只不过行为正好相反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public void addFragment(Fragment fragment, boolean moveToStateNow) &#123;</div><div class="line">    ...</div><div class="line">    makeActive(fragment);</div><div class="line">    if (!fragment.mDetached) &#123;</div><div class="line">        ...</div><div class="line">        mAdded.add(fragment);</div><div class="line">        fragment.mAdded = true;</div><div class="line">        fragment.mRemoving = false;</div><div class="line">        if (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123;</div><div class="line">            mNeedMenuInvalidate = true;</div><div class="line">        &#125;</div><div class="line">        if (moveToStateNow) &#123;</div><div class="line">            moveToState(fragment);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void makeActive(Fragment f) &#123;</div><div class="line">    if (f.mIndex &gt;= 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (mAvailIndices == null || mAvailIndices.size() &lt;= 0) &#123;</div><div class="line">        if (mActive == null) &#123;</div><div class="line">            mActive = new ArrayList&lt;Fragment&gt;();</div><div class="line">        &#125;</div><div class="line">        f.setIndex(mActive.size(), mParent);</div><div class="line">        mActive.add(f);</div><div class="line">        </div><div class="line">    &#125; else &#123;</div><div class="line">        f.setIndex(mAvailIndices.remove(mAvailIndices.size()-1), mParent);</div><div class="line">        mActive.set(f.mIndex, f);</div><div class="line">    &#125;</div><div class="line">    if (DEBUG) Log.v(TAG, &quot;Allocated fragment index &quot; + f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>addFragment会将fragment添加到 mAdded和 mActive这两个集合当中，这两个集合维护了当前activity中维护的已经添加的fragment列表和当前处于活跃状态的fragment列表，如果fragment位于mActive中，那么当activity的状态发生变化时，fragment也会跟随着发生变化。FragmentManger 如何引导fragment的状态发生变化呢？</p>
<p>这一切都发生在moveToState函数当中</p>
<p>###Fragment状态变迁：moveToState</p>
<p>Fragment状态变迁发生在用户主动发起transaction，或者fragment被add到activity之后跟随activity的生命周期变化一起发生改变。每次状态变迁最终都会走到函数moveToState，字面意思是将fragment迁移到新的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">void moveToState(Fragment f, int newState, int transit, int transitionStyle,</div><div class="line">        boolean keepActive) &#123;</div><div class="line">    // Fragments that are not currently added will sit in the onCreate() state.</div><div class="line">    ...</div><div class="line">    if (f.mState &lt; newState) &#123;</div><div class="line">        // For fragments that are created from a layout, when restoring from</div><div class="line">        // state we don&apos;t want to allow them to be created until they are</div><div class="line">        // being reloaded from the layout.</div><div class="line">        ...</div><div class="line">        switch (f.mState) &#123;</div><div class="line">            case Fragment.INITIALIZING:</div><div class="line">                ...</div><div class="line">            case Fragment.CREATED:</div><div class="line">                if (newState &gt; Fragment.CREATED) &#123;</div><div class="line">                   ...</div><div class="line">                &#125;</div><div class="line">            case Fragment.ACTIVITY_CREATED:</div><div class="line">            case Fragment.STOPPED:</div><div class="line">                if (newState &gt; Fragment.STOPPED) &#123;</div><div class="line">                    if (DEBUG) Log.v(TAG, &quot;moveto STARTED: &quot; + f);</div><div class="line">                    f.performStart();</div><div class="line">                &#125;</div><div class="line">            case Fragment.STARTED:</div><div class="line">                if (newState &gt; Fragment.STARTED) &#123;</div><div class="line">                    if (DEBUG) Log.v(TAG, &quot;moveto RESUMED: &quot; + f);</div><div class="line">                    f.performResume();</div><div class="line">                    f.mSavedFragmentState = null;</div><div class="line">                    f.mSavedViewState = null;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (f.mState &gt; newState) &#123;</div><div class="line">        switch (f.mState) &#123;</div><div class="line">            case Fragment.RESUMED:</div><div class="line">                if (newState &lt; Fragment.RESUMED) &#123;</div><div class="line">                    if (DEBUG) Log.v(TAG, &quot;movefrom RESUMED: &quot; + f);</div><div class="line">                    f.performPause();</div><div class="line">                &#125;</div><div class="line">            case Fragment.STARTED:</div><div class="line">                if (newState &lt; Fragment.STARTED) &#123;</div><div class="line">                    if (DEBUG) Log.v(TAG, &quot;movefrom STARTED: &quot; + f);</div><div class="line">                    f.performStop();</div><div class="line">                &#125;</div><div class="line">            case Fragment.STOPPED:</div><div class="line">                if (newState &lt; Fragment.STOPPED) &#123;</div><div class="line">                    if (DEBUG) Log.v(TAG, &quot;movefrom STOPPED: &quot; + f);</div><div class="line">                    f.performReallyStop();</div><div class="line">                &#125;</div><div class="line">            case Fragment.ACTIVITY_CREATED:</div><div class="line">                if (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</div><div class="line">                   ...</div><div class="line">                &#125;</div><div class="line">            case Fragment.CREATED:</div><div class="line">                if (newState &lt; Fragment.CREATED) &#123;</div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>fragment的state取值，为前面提到的七中状态，其中最低值是INITIALIZING状态，代表fragment刚创建，还未被add， 最高状态值是RESUMED,代表fragment处于前台。 所以moveToState内部分两条线，状态跃升，和状态降低，里面各有一个switch判断，注意到switch里每个case都没有break，这意味着，状态可以持续变迁，比如从INITIALIZING，一直跃升到RESUMED，将每个case都走一遍，每次case语句内，都会改变state的值。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1008428-c0809de4a37a0d74.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fragment状态变迁图"></p>
<p>比如我们常见的add操作，最后调用的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mManager.moveToState(mManager.mCurState, transition, transitionStyle, true);</div></pre></td></tr></table></figure>
<p>就是将fragment迁移到FragmentManager当前的状态，因为我们不知道用户什么时候add fragment，因此fragment被add之后，就将其状态迁移到FragmentManager当前的状态，然后跟随FragmentManager一起发生状态变迁，除非用户手动removeFragment将其从mActive列表中移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public void dispatchCreate() &#123;</div><div class="line">    mStateSaved = false;</div><div class="line">    moveToState(Fragment.CREATED, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void dispatchActivityCreated() &#123;</div><div class="line">    mStateSaved = false;</div><div class="line">    moveToState(Fragment.ACTIVITY_CREATED, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void dispatchStart() &#123;</div><div class="line">    mStateSaved = false;</div><div class="line">    moveToState(Fragment.STARTED, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void dispatchResume() &#123;</div><div class="line">    mStateSaved = false;</div><div class="line">    moveToState(Fragment.RESUMED, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void dispatchPause() &#123;</div><div class="line">    moveToState(Fragment.STARTED, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void dispatchStop() &#123;</div><div class="line">    // See saveAllState() for the explanation of this.  We do this for</div><div class="line">    // all platform versions, to keep our behavior more consistent between</div><div class="line">    // them.</div><div class="line">    mStateSaved = true;</div><div class="line"></div><div class="line">    moveToState(Fragment.STOPPED, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void dispatchReallyStop() &#123;</div><div class="line">    moveToState(Fragment.ACTIVITY_CREATED, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void dispatchDestroyView() &#123;</div><div class="line">    moveToState(Fragment.CREATED, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void dispatchDestroy() &#123;</div><div class="line">    mDestroyed = true;</div><div class="line">    execPendingActions();</div><div class="line">    moveToState(Fragment.INITIALIZING, false);</div><div class="line">    mHost = null;</div><div class="line">    mContainer = null;</div><div class="line">    mParent = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些 dispatchxxx函数由FragmentActivity状态变化引发，然后调用moveToState将处于mActive集合中的fragment的状态全部变更一次。<br>比如，当FragmentActivity pause的时候，其会通过FM<br>通知framgents进行状态变迁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Dispatch onPause() to fragments.</div><div class="line"> */</div><div class="line">@Override</div><div class="line">protected void onPause() &#123;</div><div class="line">    super.onPause();</div><div class="line">    mResumed = false;</div><div class="line">    if (mHandler.hasMessages(MSG_RESUME_PENDING)) &#123;</div><div class="line">        mHandler.removeMessages(MSG_RESUME_PENDING);</div><div class="line">        onResumeFragments();</div><div class="line">    &#125;</div><div class="line">    mFragments.dispatchPause();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###Fragment状态的保存</p>
<p>既然Fragment持有view，以及一些状态属性，那么在Activity保存自身状态以便下次恢复的时候，就需要把fragment的状态也保存起来，这样activity被系统finish掉，然后重新创建时就能恢复上次的fragment状态。那我们首先直奔FragmentActivity的onSaveInstanceState函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line"> * Save all appropriate fragment state.</div><div class="line"> */</div><div class="line">@Override</div><div class="line">protected void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">    super.onSaveInstanceState(outState);</div><div class="line">    //调用FragmentController 代理FragmentManager 保存状态</div><div class="line">    Parcelable p = mFragments.saveAllState();</div><div class="line">    if (p != null) &#123;</div><div class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</div><div class="line">    &#125;</div><div class="line">    //保存跟fragment启动activity等待result的状态</div><div class="line">    if (mPendingFragmentActivityResults.size() &gt; 0) &#123;</div><div class="line">        outState.putInt(NEXT_CANDIDATE_REQUEST_INDEX_TAG, mNextCandidateRequestIndex);</div><div class="line"></div><div class="line">        int[] requestCodes = new int[mPendingFragmentActivityResults.size()];</div><div class="line">        String[] fragmentWhos = new String[mPendingFragmentActivityResults.size()];</div><div class="line">        for (int i = 0; i &lt; mPendingFragmentActivityResults.size(); i++) &#123;</div><div class="line">            requestCodes[i] = mPendingFragmentActivityResults.keyAt(i);</div><div class="line">            fragmentWhos[i] = mPendingFragmentActivityResults.valueAt(i);</div><div class="line">        &#125;</div><div class="line">        outState.putIntArray(ALLOCATED_REQUEST_INDICIES_TAG, requestCodes);</div><div class="line">        outState.putStringArray(REQUEST_FRAGMENT_WHO_TAG, fragmentWhos);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>saveAllState函数就会将FragmentManager在重新恢复fragmentstate时需要的所有信息保存起来，小伙伴们可以跟进去看，我在这里画了张图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1008428-af38e16c42e88267.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FragmentManager状态的保存"></p>
<p>关于返回栈的保存没有详细标注，不过我们后面会再详细讲到。</p>
<p>####Fragment 状态的恢复<br>Fragment状态的恢复其实就是保存状态的逆过程，不过，额外的工作是，我们需要根据之前保存的每个active的fragmentstate来恢复创建Fragment：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public Fragment instantiate(FragmentHostCallback host, Fragment parent) &#123;</div><div class="line">    if (mInstance != null) &#123;</div><div class="line">        return mInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final Context context = host.getContext();</div><div class="line">    if (mArguments != null) &#123;</div><div class="line">        mArguments.setClassLoader(context.getClassLoader());</div><div class="line">    &#125;</div><div class="line">    //利用保存的状态恢复fragment</div><div class="line">    mInstance = Fragment.instantiate(context, mClassName, mArguments);</div><div class="line"></div><div class="line">    if (mSavedFragmentState != null) &#123;</div><div class="line">        mSavedFragmentState.setClassLoader(context.getClassLoader());</div><div class="line">        mInstance.mSavedFragmentState = mSavedFragmentState;</div><div class="line">    &#125;</div><div class="line">    mInstance.setIndex(mIndex, parent);</div><div class="line">    mInstance.mFromLayout = mFromLayout;</div><div class="line">    mInstance.mRestored = true;</div><div class="line">    mInstance.mFragmentId = mFragmentId;</div><div class="line">    mInstance.mContainerId = mContainerId;</div><div class="line">    mInstance.mTag = mTag;</div><div class="line">    mInstance.mRetainInstance = mRetainInstance;</div><div class="line">    mInstance.mDetached = mDetached;</div><div class="line">    mInstance.mFragmentManager = host.mFragmentManager;</div><div class="line"></div><div class="line">    if (FragmentManagerImpl.DEBUG) Log.v(FragmentManagerImpl.TAG,</div><div class="line">            &quot;Instantiated fragment &quot; + mInstance);</div><div class="line"></div><div class="line">    return mInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中构造Fragment的代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">  public static Fragment instantiate(Context context, String fname, @Nullable Bundle args) &#123;</div><div class="line">    try &#123;</div><div class="line">        Class&lt;?&gt; clazz = sClassMap.get(fname);</div><div class="line">        if (clazz == null) &#123;</div><div class="line">            // Class not found in the cache, see if it&apos;s real, and try to add it</div><div class="line">            clazz = context.getClassLoader().loadClass(fname);</div><div class="line">            sClassMap.put(fname, clazz);</div><div class="line">        &#125;</div><div class="line">        Fragment f = (Fragment)clazz.newInstance();</div><div class="line">        if (args != null) &#123;</div><div class="line">            args.setClassLoader(f.getClass().getClassLoader());</div><div class="line">            f.mArguments = args;</div><div class="line">        &#125;</div><div class="line">        return f;</div><div class="line">    &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">        throw new InstantiationException(&quot;Unable to instantiate fragment &quot; + fname</div><div class="line">                + &quot;: make sure class name exists, is public, and has an&quot;</div><div class="line">                + &quot; empty constructor that is public&quot;, e);</div><div class="line">    &#125; catch (java.lang.InstantiationException e) &#123;</div><div class="line">        throw new InstantiationException(&quot;Unable to instantiate fragment &quot; + fname</div><div class="line">                + &quot;: make sure class name exists, is public, and has an&quot;</div><div class="line">                + &quot; empty constructor that is public&quot;, e);</div><div class="line">    &#125; catch (IllegalAccessException e) &#123;</div><div class="line">        throw new InstantiationException(&quot;Unable to instantiate fragment &quot; + fname</div><div class="line">                + &quot;: make sure class name exists, is public, and has an&quot;</div><div class="line">                + &quot; empty constructor that is public&quot;, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是不是发现这段代码灰常熟悉，很多人恐怕都遇到过代码中描述的异常。因为Fragment在恢复时，是利用反射的方式去创建，首先利用类加载器去加载类，然后调用其pubic empty 构造函数去创建fragment。</p>
<p>所以如果Fragment不是public的，或者fragment没有public的无参构造函数，那么你的应用肯定会碰到这些异常，只不过你在调试的时候可能无法发现，因为你的手机环境太好，构不成saveInstanceState然后恢复它们的条件。</p>
<p>如果我们用Android studio 模板去创建fragment，那么他会给我们默认实现一个newInstance的静态构造函数，并<strong>把构造参数写在argument</strong>里，因为前面那张图里可以看到，argument会在保存fragment状态时保存起来的。另外<strong>不要写任何带参数的构造函数</strong>，因为这样子，默认构造函数就会被隐藏，除非你手动去实现它。 话说这个instantiate是个public方法，因此你也可以直接调用这个函数去创建fragment，只不过它使用起来不是那么方便，使用者不知道我们需要往里面传什么参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyFragment.instantiate(activity, MyFragment.getClass().getName(), args)</div></pre></td></tr></table></figure>
<p>#####臭名昭著的 “Can not perform this action after onSaveInstanceState”</p>
<p>这里不得不提一提开发中经常会碰到的一个异常，异常抛出时的message为：“Can not perform this action after onSaveInstanceState”， 意为，FragmentTransaction不能再onSaveInstanceState后提交，为什么会抛出这样一个异常呢，因为FragmentManager认为在onSaveInstanceState 发生之后提交的transaction不能在下次Fm恢复时得到恢复，继而认为这样做是危险的，拒绝提交，除非你指定了allowStateLoss，即允许状态的丢失。</p>
<p>开发者只需要用<strong>commitAllowingStateLoss</strong>，即可以成功提交这样的transaction，即使它有可能会丢失状态。</p>
<p>###Fragment返回栈<br>使用fragmentTransaction的时候可以将其加入返回栈，这样用户就可以有机会去撤销这一动作，将其从返回栈中pop出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public FragmentTransaction addToBackStack(String name) &#123;</div><div class="line">    if (!mAllowAddToBackStack) &#123;</div><div class="line">        throw new IllegalStateException(</div><div class="line">                &quot;This FragmentTransaction is not allowed to be added to the back stack.&quot;);</div><div class="line">    &#125;</div><div class="line">    //标记 即将加入返回栈</div><div class="line">    mAddToBackStack = true;</div><div class="line">    //标记在返回栈中的名字</div><div class="line">    mName = name;</div><div class="line">    return this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//transaction提交</div><div class="line">public void run() &#123;</div><div class="line">    //...</div><div class="line"></div><div class="line">	//加入到FragmentManager的返回栈中</div><div class="line">    if (mAddToBackStack) &#123;</div><div class="line">        mManager.addBackStackState(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//FragmentManager添加返回栈</div><div class="line"> void addBackStackState(BackStackRecord state) &#123;</div><div class="line">    if (mBackStack == null) &#123;</div><div class="line">        mBackStack = new ArrayList&lt;BackStackRecord&gt;();</div><div class="line">    &#125;</div><div class="line">    mBackStack.add(state);</div><div class="line">    //通知返回栈监听者们发生改变</div><div class="line">    reportBackStackChanged();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FragmentManager中有一个叫做mBackStack的列表，保存了添加到返回栈的所有record， 当用户选择popBackStack的时候，就可以将其pop出来。</p>
<p>我们常用的pop操作就是popBackStack函数，其实FM还提供了很多pop操作，它可以指定以name和id指定pop哪个record，还可以指定flag：<strong>POP_BACK_STACK_INCLUSIVE</strong>, 如果指定了这个flag就表示将name或者id相等且连续的record全部pop出来。这些操作最后都调用了函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">boolean popBackStackState(Handler handler, String name, int id, int flags) &#123;</div><div class="line">    //如果返回栈不存在，立即返回</div><div class="line">    if (mBackStack == null) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    //如果name、id、POP_BACK_STACK_INCLUSIVE全部都没有设置，直接移除栈顶的一个record</div><div class="line">    if (name == null &amp;&amp; id &lt; 0 &amp;&amp; (flags&amp;POP_BACK_STACK_INCLUSIVE) == 0) &#123;</div><div class="line">        int last = mBackStack.size()-1;</div><div class="line">        if (last &lt; 0) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        final BackStackRecord bss = mBackStack.remove(last);</div><div class="line">        SparseArray&lt;Fragment&gt; firstOutFragments = new SparseArray&lt;Fragment&gt;();</div><div class="line">        SparseArray&lt;Fragment&gt; lastInFragments = new SparseArray&lt;Fragment&gt;();</div><div class="line">        bss.calculateBackFragments(firstOutFragments, lastInFragments);</div><div class="line">        bss.popFromBackStack(true, null, firstOutFragments, lastInFragments);</div><div class="line">        reportBackStackChanged();</div><div class="line">    &#125; else &#123;</div><div class="line">        int index = -1;</div><div class="line">        if (name != null || id &gt;= 0) &#123;</div><div class="line">            //从栈顶开始寻找一个name或者id匹配的record，找到即跳出循环</div><div class="line">            index = mBackStack.size()-1;</div><div class="line">            while (index &gt;= 0) &#123;</div><div class="line">                BackStackRecord bss = mBackStack.get(index);</div><div class="line">                if (name != null &amp;&amp; name.equals(bss.getName())) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (id &gt;= 0 &amp;&amp; id == bss.mIndex) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                index--;</div><div class="line">            &#125;</div><div class="line">            //如果没找到，函数返回</div><div class="line">            if (index &lt; 0) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            //如果设置了POP_BACK_STACK_INCLUSIVE,则向栈底方向寻找连续匹配的record</div><div class="line">            if ((flags&amp;POP_BACK_STACK_INCLUSIVE) != 0) &#123;</div><div class="line">                index--;</div><div class="line">                // Consume all following entries that match.</div><div class="line">                while (index &gt;= 0) &#123;</div><div class="line">                    BackStackRecord bss = mBackStack.get(index);</div><div class="line">                    if ((name != null &amp;&amp; name.equals(bss.getName()))</div><div class="line">                            || (id &gt;= 0 &amp;&amp; id == bss.mIndex)) &#123;</div><div class="line">                        index--;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (index == mBackStack.size()-1) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        //弹出从栈顶到连续相同匹配的record记录位置的所有record，加入集合states中</div><div class="line">        final ArrayList&lt;BackStackRecord&gt; states</div><div class="line">                = new ArrayList&lt;BackStackRecord&gt;();</div><div class="line">        for (int i=mBackStack.size()-1; i&gt;index; i--) &#123;</div><div class="line">            states.add(mBackStack.remove(i));</div><div class="line">        &#125;</div><div class="line">     </div><div class="line">        final int LAST = states.size()-1;</div><div class="line">        SparseArray&lt;Fragment&gt; firstOutFragments = new SparseArray&lt;Fragment&gt;();</div><div class="line">        SparseArray&lt;Fragment&gt; lastInFragments = new SparseArray&lt;Fragment&gt;();</div><div class="line">        //计算在连续record中，最先remove的fragment集合 和 最后进入的fragment集合</div><div class="line">        for (int i=0; i&lt;=LAST; i++) &#123;</div><div class="line">            states.get(i).calculateBackFragments(firstOutFragments, lastInFragments);</div><div class="line">        &#125;</div><div class="line">        BackStackRecord.TransitionState state = null;</div><div class="line">        //对这些record列表执行逆操作</div><div class="line">        for (int i=0; i&lt;=LAST; i++) &#123;</div><div class="line">            if (DEBUG) Log.v(TAG, &quot;Popping back stack state: &quot; + states.get(i));</div><div class="line">            state = states.get(i).popFromBackStack(i == LAST, state,</div><div class="line">                    firstOutFragments, lastInFragments);</div><div class="line">        &#125;</div><div class="line">        //通知返回栈监听器更新</div><div class="line">        reportBackStackChanged();</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中比较复杂的两步，一步是calculateBackFragments， 还有一个是popFromBackStack，我们先看calculateBackFragments：</p>
<p>为什么需要计算calculateBackFragments? 其实是因为涉及到动画的方面，在一次在一次transaction中可能会移除和添加多次fragments，这样动画的编排就必须按顺序来，这次分析中，我们就不对动画做过多分析了，因为这是相对来说次要点的知识点。所以我们集中关心BackStackRecord 的popFromBackStack函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">public TransitionState popFromBackStack(boolean doStateMove, TransitionState state,</div><div class="line">            SparseArray&lt;Fragment&gt; firstOutFragments, SparseArray&lt;Fragment&gt; lastInFragments) &#123;</div><div class="line">    </div><div class="line">    //...动画相关</div><div class="line"></div><div class="line"></div><div class="line">    int transitionStyle = state != null ? 0 : mTransitionStyle;</div><div class="line">    int transition = state != null ? 0 : mTransition;</div><div class="line">    Op op = mTail;</div><div class="line">    while (op != null) &#123;</div><div class="line">        int popEnterAnim = state != null ? 0 : op.popEnterAnim;</div><div class="line">        int popExitAnim= state != null ? 0 : op.popExitAnim;</div><div class="line">        switch (op.cmd) &#123;</div><div class="line">            case OP_ADD: &#123;</div><div class="line">                Fragment f = op.fragment;</div><div class="line">                f.mNextAnim = popExitAnim;</div><div class="line">                mManager.removeFragment(f,</div><div class="line">                        FragmentManagerImpl.reverseTransit(transition), transitionStyle);</div><div class="line">            &#125; break;</div><div class="line">            case OP_REPLACE: &#123;</div><div class="line">                Fragment f = op.fragment;</div><div class="line">                if (f != null) &#123;</div><div class="line">                    f.mNextAnim = popExitAnim;</div><div class="line">                    mManager.removeFragment(f,</div><div class="line">                            FragmentManagerImpl.reverseTransit(transition), transitionStyle);</div><div class="line">                &#125;</div><div class="line">                if (op.removed != null) &#123;</div><div class="line">                    for (int i=0; i&lt;op.removed.size(); i++) &#123;</div><div class="line">                        Fragment old = op.removed.get(i);</div><div class="line">                        old.mNextAnim = popEnterAnim;</div><div class="line">                        mManager.addFragment(old, false);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; break;</div><div class="line">            case OP_REMOVE: &#123;</div><div class="line">                Fragment f = op.fragment;</div><div class="line">                f.mNextAnim = popEnterAnim;</div><div class="line">                mManager.addFragment(f, false);</div><div class="line">            &#125; break;</div><div class="line">            case OP_HIDE: &#123;</div><div class="line">                Fragment f = op.fragment;</div><div class="line">                f.mNextAnim = popEnterAnim;</div><div class="line">                mManager.showFragment(f,</div><div class="line">                        FragmentManagerImpl.reverseTransit(transition), transitionStyle);</div><div class="line">            &#125; break;</div><div class="line">            case OP_SHOW: &#123;</div><div class="line">                Fragment f = op.fragment;</div><div class="line">                f.mNextAnim = popExitAnim;</div><div class="line">                mManager.hideFragment(f,</div><div class="line">                        FragmentManagerImpl.reverseTransit(transition), transitionStyle);</div><div class="line">            &#125; break;</div><div class="line">            case OP_DETACH: &#123;</div><div class="line">                Fragment f = op.fragment;</div><div class="line">                f.mNextAnim = popEnterAnim;</div><div class="line">                mManager.attachFragment(f,</div><div class="line">                        FragmentManagerImpl.reverseTransit(transition), transitionStyle);</div><div class="line">            &#125; break;</div><div class="line">            case OP_ATTACH: &#123;</div><div class="line">                Fragment f = op.fragment;</div><div class="line">                f.mNextAnim = popEnterAnim;</div><div class="line">                mManager.detachFragment(f,</div><div class="line">                        FragmentManagerImpl.reverseTransit(transition), transitionStyle);</div><div class="line">            &#125; break;</div><div class="line">            default: &#123;</div><div class="line">                throw new IllegalArgumentException(&quot;Unknown cmd: &quot; + op.cmd);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        op = op.prev;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (doStateMove) &#123;</div><div class="line">        mManager.moveToState(mManager.mCurState,</div><div class="line">                FragmentManagerImpl.reverseTransit(transition), transitionStyle, true);</div><div class="line">        state = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (mIndex &gt;= 0) &#123;</div><div class="line">        mManager.freeBackStackIndex(mIndex);</div><div class="line">        mIndex = -1;</div><div class="line">    &#125;</div><div class="line">    return state;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本上从多个switch-case分支语句里就可以看出pop执行的就是commit的反操作，因为因为transaction都是成对存在的</p>
<ul>
<li>add &lt;-&gt; remove</li>
<li>attach &lt;-&gt; detach</li>
<li>show &lt;-&gt; hide</li>
<li>replace( remove x n + add x m) &lt;-&gt; replace ( remove x m + add x n)</li>
</ul>
<p>####返回栈的状态的保存<br>返回栈状态的保存，相当于要把整个BackStackRecord的列表保存下来，以便下次恢复，前面提到BackStackRecord，可以跟 BackStackState这个parcelable映射起来。基本上BackStackRecord都是可以parcel的类型，出了Op链表，Op链表映射为BackStackState的int[] mOps;</p>
<p>看完了返回栈，基本上有关Fragment的核心知识点都了解的差不多了，当然我们也跳过了一些知识点，比如有关动画的部分、ChildFragmentManager等。但基本上Fragment在使用到遇到问题的部分，都可以从上面的分析中找到原因。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/09/06/deep-into-android-fragment/" data-id="cisr69x0q0002x2kw4hrtguw0" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-nav"><a href="/2016/09/06/android-package-essentials/" class="next">Android打包系列-基础知识</a></div><div data-thread-key="2016/09/06/deep-into-android-fragment/" data-title="从源码角度剖析Fragment核心知识点" data-url="http://yoursite.com/2016/09/06/deep-into-android-fragment/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/09/06/deep-into-android-fragment/" data-title="从源码角度剖析Fragment核心知识点" data-url="http://yoursite.com/2016/09/06/deep-into-android-fragment/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/deep-into-android-fragment/">从源码角度剖析Fragment核心知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/android-package-essentials/">Android打包系列-基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/custom-gradle-plugin-1/">Gradle自定义Plugin(上)</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'qinjunli123'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>