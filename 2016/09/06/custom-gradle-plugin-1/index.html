<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Gradle自定义Plugin(上) | Hexo</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Gradle自定义Plugin(上)</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Gradle自定义Plugin(上)</h1><div class="post-meta">Sep 6, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/09/06/custom-gradle-plugin-1/" href="/2016/09/06/custom-gradle-plugin-1/#comments" class="ds-thread-count"></a><div class="post-content"><p>这篇文章讲给大家带来gradle打包系列中的高级用法-自己动手编写gradle插件。我们平常在做安卓开发时，都会在android这个插件提供的功能内使用，大部分情况下，配置好这个插件就够了，但是有时候我们想做一些额外的拓展，比如对build输出的Apk进行上传。当然通过在工程中添加额外的task就可以了，但是如果把这个功能做成插件，就会更加通用。那今天我们就从groovy基础语法开始，剖析一下gradle的原理，最后教大家如何自定义Gradle插件。</p>
<p>这篇文章里面会涉及到Groovy的语法，gradle的基础知识等等，我不会专门去讲，但是凡是在与本次主题相关的概念都会给大家梳理一下。</p>
<p>在Gradle构建中，我们需要在build.gradle文件或者settings.gradle里面写上自己的配置，这些配置语句，看起来是符合某个标准的，就像SQL语句那样，我们如果要查询就得用Select语句，然后按照Select支持的语法来书写。我们如果想对gradle的构建过程进行配置就得遵循Gradle支持的语法。这样在某个领域通用的语言就叫做DSL(Domain specific languange )， 直译就是领域专用语言。</p>
<p>Martin Fowler将DSL分为两类：外部DSL和内部DSL。外部DSL是一种独立的可解析的语言，举一个最常见的是例子，SQL，它专注于数据库的操作。内部DSL是通用语言所暴露的用来执行特定任务的API，它利用语言本身的特性，将API以特殊的形式（或者格式）暴露出来的，就像gradle，它是基于groovy的，groovy是是一种通用语言，但是gradle基于groovy的语法，构建了自己的一套DSL，我们在配置gradle时，必须首先遵循groovy的语法，其次还必须遵循Gradle 的DSL标准。</p>
<p>闲话少说，要自己动手编写Gradle插件，必须首先对Groovy的语法有一定的了解，尤其是Groovy中的闭包语法。</p>
<h2 id="Groovy-essentials"><a href="#Groovy-essentials" class="headerlink" title="Groovy essentials"></a>Groovy essentials</h2><p>Groovy是一种基于JVM的语言，了解groovy的一些语法，对于理解并用活gradle有很大的帮助</p>
<h3 id="Groovy语法特性一：方法的输入参数优化"><a href="#Groovy语法特性一：方法的输入参数优化" class="headerlink" title="Groovy语法特性一：方法的输入参数优化"></a>Groovy语法特性一：方法的输入参数优化</h3><p>groovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号。比如这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def func(String a)&#123;</div><div class="line">  println(a)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func &apos;hello&apos;</div></pre></td></tr></table></figure>
<p>在gradle有大量省略括号调用函数的例子，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    compileSdkVersion rootProject.ext.compileSdkVersion</div><div class="line">    buildToolsVersion rootProject.ext.buildToolsVersion</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如这里compileSdkVersion 和 buildToolsVersion 其实就是调用了同样名字的两个函数，在AndroidStudio里面可以点进去查看函数实现</p>
<p>当然如果某个函数没有参数，那就不能省略括号，否则会当成一个变量使用</p>
<h3 id="Groovy语法特性二：闭包"><a href="#Groovy语法特性二：闭包" class="headerlink" title="Groovy语法特性二：闭包"></a>Groovy语法特性二：闭包</h3><p>闭包(Closure)是groovy中一个很重要的概念，而且在gradle中广泛使用。what is closure? 简而言之，闭包是一个可执行的代码块，类似于C语言中的函数指针。在很多动态类型语言中都有广泛的使用，java8 中也有类似的概念:lambda expression，但是groovy中的闭包和java8中的lambda表达式相比又有很多的不同之处。稍后会提到，先来学习一下groovy中的闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def listener = &#123; e -&gt; println &quot;Clicked on $e.source&quot; &#125;</div></pre></td></tr></table></figure>
<p>此时listener就是一个闭包，</p>
<h4 id="闭包参数"><a href="#闭包参数" class="headerlink" title="闭包参数"></a>闭包参数</h4><p>闭包参数的构成有三个元素，</p>
<ul>
<li>一个可选的参数类型</li>
<li>一个可选的参数默认值</li>
<li>参数名称</li>
</ul>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def xx = &#123;</div><div class="line">  int a=2 -&gt;</div><div class="line">   a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="闭包对象"><a href="#闭包对象" class="headerlink" title="闭包对象"></a>闭包对象</h4><p> grooy中闭包是Closure类型的实例，比如上面的闭包我们又可以定义为:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Closure xx = &#123;</div><div class="line">  int a=2 -&gt;</div><div class="line">   a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而且你可以制定一个可选的返回类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Closure&lt;Integer&gt; xx = &#123;</div><div class="line">  int a=2 -&gt;</div><div class="line">   a + b</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> <strong>隐含参数</strong><br> 如果闭包内没有生命任何参数，没有-&gt;， 那么闭包内置会定义一个隐含参数it</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def greeting = &#123; &quot;Hello, $it!&quot; &#125;</div></pre></td></tr></table></figure>
<h5 id="闭包代理-Closure-delegate"><a href="#闭包代理-Closure-delegate" class="headerlink" title="闭包代理(Closure delegate)"></a>闭包代理(Closure delegate)</h5><p> 闭包区别lambda表达式的一个显著的区别在与groovy中的闭包可以指定代理。</p>
<p> 实际上在闭包内，可以拿到三个对象:</p>
<ul>
<li><p>This  对应于定义闭包时包含他的class，可以通过getThisObject或者直接this获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> class EnclosedInInnerClass &#123;</div><div class="line">    class Inner &#123;</div><div class="line">        Closure cl = &#123; this &#125;                               </div><div class="line">    &#125;</div><div class="line">    void run() &#123;</div><div class="line">        def inner = new Inner()</div><div class="line">        assert inner.cl() == inner                          </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>owner 对应于定义闭包时包含他的对象，可以通过getOwner或者直接owner获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> class EnclosedInInnerClass &#123;</div><div class="line">   void run() &#123;</div><div class="line">      def nestedClosures = &#123;</div><div class="line">          def cl = &#123; owner &#125;                               </div><div class="line">          cl()</div><div class="line">      &#125;</div><div class="line">      assert nestedClosures() == nestedClosures            </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>delegate  闭包对象可以指定一个第三方对象作为其代理，用于函数调用或者属性的指定，可以通过getDelgate或者delegate属性获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    String name</div><div class="line">&#125;</div><div class="line">class Thing &#123;</div><div class="line">    String name</div><div class="line">&#125;</div><div class="line"></div><div class="line">def p = new Person(name: &apos;Norman&apos;)</div><div class="line">def t = new Thing(name: &apos;Teapot&apos;)</div><div class="line"></div><div class="line">def upperCasedName = &#123; delegate.name.toUpperCase() &#125;</div><div class="line"></div><div class="line">upperCasedName.delegate = p</div><div class="line">assert upperCasedName() == &apos;NORMAN&apos;</div><div class="line">upperCasedName.delegate = t</div><div class="line">assert upperCasedName() == &apos;TEAPOT&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="代理策略"><a href="#代理策略" class="headerlink" title="代理策略"></a>代理策略</h4><p>如果在闭包内，没有明确指定属性或者方法的调用是发生在this, owner,delegate上时，就需要根据代理策略来判断到底该发生在谁身上。有如下几种代理策略:</p>
<ul>
<li><p>Closure.OWNER_FIRST 默认的策略，如果属性或者方法在owner中存在，调用就发生在owner身上，否则发生在delegate上</p>
</li>
<li><p>Closure.DELEGATE_FIRST 跟owner_first正好相反</p>
</li>
<li><p>Closure.OWNER_ONLY 忽略delegate</p>
</li>
<li><p>Closure.DELEGATE_ONLY 忽略owner</p>
</li>
<li><p>Closure.TO_SELF 调用不发生在owner或delegate上，只发生在闭包内</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    String name</div><div class="line">    def pretty = &#123; &quot;My name is $name&quot; &#125;             </div><div class="line">    String toString() &#123;</div><div class="line">        pretty()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Thing &#123;</div><div class="line">    String name                                     </div><div class="line">&#125;</div><div class="line"></div><div class="line">def p = new Person(name: &apos;Sarah&apos;)</div><div class="line">def t = new Thing(name: &apos;Teapot&apos;)</div><div class="line"></div><div class="line">#调用发生在owner</div><div class="line">assert p.toString() == &apos;My name is Sarah&apos;           </div><div class="line">p.pretty.delegate = t                               </div><div class="line">assert p.toString() == &apos;My name is Sarah&apos;</div><div class="line"></div><div class="line">#调用发生在delegate</div><div class="line">p.pretty.resolveStrategy = Closure.DELEGATE_FIRST</div><div class="line">assert p.toString() == &apos;My name is Teapot&apos;</div></pre></td></tr></table></figure>
<p>groovy中的闭包还有很多种高级的使用方法，但是在gradle中比较少用到，你可以点击这个链接<a href="http://www.groovy-lang.org/closures.html" target="_blank" rel="external"> Groovy闭包 </a>去了解。</p>
<h3 id="Groovy语法特性三：类的Property"><a href="#Groovy语法特性三：类的Property" class="headerlink" title="Groovy语法特性三：类的Property"></a>Groovy语法特性三：类的Property</h3><p>Groovy中的class和java中的Class区别不大，值得我们关注的区别是，如果类的成员变量没有加任何权限访问，则称为Property, 否则是Field，filed和Java中的成员变量相同，但是Property的话，它是一个private field和getter setter的集合，也就是说groovy会自动生成getter setter方法，因此在类外面的代码，都是会透明的调用getter和setter方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> class Person &#123;</div><div class="line">    String name</div><div class="line">    void name(String name) &#123;</div><div class="line">        this.name = &quot;Wonder$name&quot;       </div><div class="line">    &#125;</div><div class="line">    String wonder() &#123;</div><div class="line">        this.name                       </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">def p = new Person()</div><div class="line">p.name = &apos;Marge&apos;                      //调用setter方法                  </div><div class="line">assert p.name == &apos;Marge&apos;             //调用getter方法    </div><div class="line">p.name(&apos;Marge&apos;)                         </div><div class="line">assert p.wonder() == &apos;WonderMarge&apos;</div></pre></td></tr></table></figure></p>
<p>我们在gradle脚本中经常会看到这样的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//gradle扩展</div><div class="line">ext&#123;</div><div class="line">    name &apos;haha&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里name属性实际上就是调用了setName方法，并且利用了之前说的省略括号的特性，实际上就是 调用了setName(‘haha’)<br>还有我们常见的在project中创建task的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">task taskName &lt;&lt; &#123;</div><div class="line">    doSomeThing</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际上就是调用了task(taskName).leftShift(closure),这里又扯出来Groovy中的两个语法特性，一个是<strong>操作符重载</strong>，这个早C++里面用到很多，这个语法特性可以让你的类，可以像基本类型一样使用普通的操作符，比如 + - * / 等，只需要你重载了这些函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Bucket &#123;</div><div class="line">    int size</div><div class="line"></div><div class="line">    Bucket(int size) &#123; this.size = size &#125;</div><div class="line"></div><div class="line">    Bucket plus(Bucket other) &#123;                     </div><div class="line">        return new Bucket(this.size + other.size)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">def b1 = new Bucket(4)</div><div class="line">def b2 = new Bucket(11)</div><div class="line">assert (b1 + b2).size == 15   //b1 和b2 可以直接相加</div></pre></td></tr></table></figure></p>
<p>上面那个task的例子，就是因为task类重载了leftShift，因此可以使用&lt;&lt; 操作符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//Project类</div><div class="line">Task task(String var1) throws InvalidUserDataException;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//Task类</div><div class="line">Task leftShift(Closure var1);</div></pre></td></tr></table></figure>
<p>task例子中用到的另外一个语法特性是<strong>Command Chains</strong>， 这个特性不仅可以省略函数调用中的括号，而且可以省略，连续函数调用中的. 点号, 比如<br>a(b).c(d) 这里a c是函数, b,d是函数参数, 就可以缩写为a b c d。这个特性强大之处在于不仅适用于单个参数类型函数，而且适用于多个参数类型的函数，当参数类型为闭包时同样适用, 比如这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">task xxxxx  doLast &#123; println &quot;task doLast 1&quot;&#125;  doLast &#123; println &quot;task doLast 2&quot;&#125;</div></pre></td></tr></table></figure>
<p>这么看起来是不是跟sql语句就有点儿像了，哈哈，DSL。</p>
<p>上面所提到的那些groovy的语法特性，构成了Gradle中DSL的基础，理解了这些就能理解groovy是如何为gradle dsl提供支撑的。</p>
<p>说完了groovy的这些基础语法，我们再来学习一下gradle的一些基础知识，这样就不难理解。</p>
<p>##Gradle Basics<br>gradle的语法和入门指导，可以从gradle的官网上找到，如果需要像教科书那样的教程，完成可以去官网上学习，我们这里只会从中提炼出一些核心知识，了解了这些核心知识，我认为就足够了。</p>
<p>我们在AndroidStudio中创建基于Gradle的project时，会默认生成一个多项目结构的Gradle工程，像下面这样</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1008428-6afc513992d405fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gradle muti-project structure"></p>
<p>对于这个project，我们能对构建过程做出改变的，就只能发生在这些.gradle文件中，这些文件称为Build Script构建脚本。对于Gradle中的构建脚本，你一方面可以理解为配置文件，每一种类型脚本文件都是对某一中类型的构建对象进行配置。但另一方面你可以<strong>把每个脚本理解为一个Groovy闭包</strong>，这样我们在执行构建脚本时，就是在执行每一个闭包函数，只不过<strong>每个闭包所设置的delegate不一样</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1008428-1ab1ced587697723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>###Build Script<br>Gradle中共有三种类型的构建脚本:build script, init script, setting script，分别对应三种类型的Gradle构建对象。</p>
<p>我们先来说说这三种不同的构建脚本：</p>
<h4 id="Init-Script"><a href="#Init-Script" class="headerlink" title="Init Script"></a>Init Script</h4><p>init script我们大部分人并不常用，但是它确实可以配置，你可以通过如下方式指定init script</p>
<ol>
<li>通过在命令行里指定gradle参数 -I 或者–init-script <pathtoinit.gradle></pathtoinit.gradle></li>
<li>在<em>USER_HOME</em>/.gradle 或者 <em>USER_HOME</em>/.gradle/init.d目录下，放置init.gradle文件</li>
<li>将init.gradle放置在<em>GRADLE_HOME</em>/init.d/目录下</li>
</ol>
<p>init.gradle脚本中，我们可以对当前的build做出一些全局配置，比如全局依赖，何处寻找插件等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">initscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        mavenCentral()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath group: &apos;org.apache.commons&apos;, name: &apos;commons-math&apos;, version: &apos;2.0&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Settings-script"><a href="#Settings-script" class="headerlink" title="Settings script"></a>Settings script</h4><p>Settings.gradle文件在项目创建于rootProject根目录下，因为settings.gradle对于多项目工程来说是必须的，然而对于单项目project来说不是必须的。Settings脚本的Delegate是Settings对象，因此我们可以瞅瞅Settings类里面都有哪些函数</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1008428-11954bf4962adcc2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Settings类"></p>
<p>我们可以看到有常见的include 函数 和 includeFlat函数， 因为我们最常做的事情就是在settings脚本里面写上include ‘:app’这样的函数调用语句，根据groovy的语法，他就是在gradle生成的settings对象调用函数 include(‘app’)<br>include接受的参数是一个string数组，因此include后可以加很多参数，这个函数的意义就是：<strong>指明那些子project参与这次gradle构建</strong></p>
<p>####Build Script<br>build.gradle脚本文件使我们最常见的，绝大部分配置工作发生在这里，因为它的Delegate就是Project，如果是多项目结构，则build.gradle文件分为两种，rootProject下的build.gradle文件，subProject下的build.gradle文件，每个build.gradle文件执行时的代理project都不一样。</p>
<p>project中有很多函数，比如我们最常见的apply， dependencies等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//apply一个插件或者脚本</div><div class="line">void apply(Map&lt;String, ?&gt; options);</div><div class="line">//配置当前project的依赖</div><div class="line">void dependencies(Closure configureClosure);</div><div class="line">//配置当前脚本的classpath</div><div class="line">void buildscript(Closure configureClosure);</div></pre></td></tr></table></figure>
<p>这些函数都可以在AndroidStudio里点击到Project里面去一探究竟，如果理解了groovy的闭包，相信不会再对build.gradle里面那些配置感到神秘，他们也只是在<strong>某个对象上调用了某个函数，传入了某个闭包或者其他对象作为参数</strong></p>
<p>至于这里面提到的gradle, project, settings对象何时生成，我们可以通过了解gradle的build lifecycle了解到</p>
<h3 id="Build-life-cycle"><a href="#Build-life-cycle" class="headerlink" title="Build life cycle"></a>Build life cycle</h3><p>Gradle最终的目的是运行gradle中的task（task我们后面会单独介绍）</p>
<blockquote>
<p>gradle  <sometask></sometask></p>
</blockquote>
<p>在gradle运行的过程中，gradle会经历三个阶段</p>
<ol>
<li><p><strong>Initialization</strong> 在这个阶段，gradle会首先生成gradle对象和settings对象，然后执行init.gradle中脚本，再执行settings.gradle中的脚本，根绝settings.gradle给每个项目生成一个project对象</p>
</li>
<li><p><strong>Configuration</strong> 在这个阶段，gradle会运行参与本次构建的所有project中的build.gradle文件，这个阶段完成之后，每个project中的所有task以及相互关系就确定了</p>
</li>
<li><p><strong>Execution</strong> 执行阶段，gradle会根据传给它的task名字运行指定的task</p>
</li>
</ol>
<p>####监听器</p>
<p>我们还可以在上述build lifecycle中添加额外的监听器，监听某件事情的完成，这样我们就可以对gradle的正常运行流程做干预，比如我们想<strong>监听某个subProject 配置</strong>完毕，打印日志。我们可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gradle.afterProject &#123; project -&gt;</div><div class="line">    println(&apos;Project &apos; + project + &apos;  has evaluated&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码通常需要添加在rootProject的build.gradle脚本中，也可以添加到subProject中(只要能通过gradle获取到Gradle对象），但是这个监听器的安装需要发生在subProject在evaluated时，因此如果前面已经有project参与过evaluate，就不会得到监听。<br>还可以通过如下方法监听：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">    afterEvaluate &#123; project -&gt;</div><div class="line">        if (project.hasTests) &#123;</div><div class="line">            println &quot;Adding test task to $project&quot;</div><div class="line">            project.task(&apos;test&apos;) &lt;&lt; &#123;</div><div class="line">                println &quot;Running tests for $project&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>监听task的创建</strong><br>可以在build.gradle中通过如下方式监听task的创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tasks.whenTaskAdded &#123; task -&gt;</div><div class="line">    task.ext.srcDir = &apos;src/main/java&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>监听整个task关系图的创建</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gradle.taskGraph.whenReady &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>监听某个task的执行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//监听整个build完毕</div><div class="line">gradle.buildFinished &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">//监听某个task开始执行，结束执行</div><div class="line">gradle.taskGraph.addTaskExecutionListener(new TaskExecutionListener() &#123;</div><div class="line">    @Override</div><div class="line">    void beforeExecute(Task task) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void afterExecute(Task task, TaskState state) &#123;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>任意类型监听器</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Adds the given listener to this build. The listener may implement any of the given listener interfaces:</div><div class="line"> *</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt;&#123;@link org.gradle.BuildListener&#125;</div><div class="line"> * &lt;li&gt;&#123;@link org.gradle.api.execution.TaskExecutionGraphListener&#125;</div><div class="line"> * &lt;li&gt;&#123;@link org.gradle.api.ProjectEvaluationListener&#125;</div><div class="line"> * &lt;li&gt;&#123;@link org.gradle.api.execution.TaskExecutionListener&#125;</div><div class="line"> * &lt;li&gt;&#123;@link org.gradle.api.execution.TaskActionListener&#125;</div><div class="line"> * &lt;li&gt;&#123;@link org.gradle.api.logging.StandardOutputListener&#125;</div><div class="line"> * &lt;li&gt;&#123;@link org.gradle.api.tasks.testing.TestListener&#125;</div><div class="line"> * &lt;li&gt;&#123;@link org.gradle.api.tasks.testing.TestOutputListener&#125;</div><div class="line"> * &lt;li&gt;&#123;@link org.gradle.api.artifacts.DependencyResolutionListener&#125;</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> *</div><div class="line"> * @param listener The listener to add. Does nothing if this listener has already been added.</div><div class="line"> */</div><div class="line">public void addListener(Object listener);</div></pre></td></tr></table></figure></p>
<p>可以通过gradle.addListener(listener) 传入一个gradle支持的listener类型。上面addListener的注释中列出了它支持的监听器类别，你的listener可以任意实现其中的接口来满足你的需求。</p>
<h3 id="创建Task"><a href="#创建Task" class="headerlink" title="创建Task"></a>创建Task</h3><p>创建一个简单的task的语法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">task &lt;taskName&gt; &lt;&lt; &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将groovy语法的时候，我们提到过，这句话应该这么理解：</p>
<ol>
<li>首先调用project的task方法，传入一个taskName,返回一个task</li>
<li>调用task的leftShift 方法 传入一个closure，根据leftShift的解释，我们知道这个闭包将添加到task的action list里去。在任务执行的时候运行</li>
</ol>
<p>有时候，我们可能会错写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">task &lt;taskName&gt; &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>少了这个&lt;&lt; 操作符，意思就大不一样了，这个时候调用的函数为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//Project类</div><div class="line">Task task(String name, Closure configureClosure);</div></pre></td></tr></table></figure>
<p>这时，第二个参数closure用来配置task，在task创建的时候执行，而不是在task执行的时候运行。不过我们可以在这个闭包内配置task的一些属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//指定Copy类型task的属性</div><div class="line">task copyDocs(type: Copy) &#123;</div><div class="line">   from &apos;src/main/doc&apos;</div><div class="line">   into &apos;build/target/doc&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然我们还可以这样指定task的行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">task exampleTask &#123;</div><div class="line">    doLast&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">task exampleTask doLast&#123;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为Task的doLast函数的作用和&lt;&lt;操作符一样。</p>
<p>task的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">task name(type: Type)&#123;</div><div class="line">    </div><div class="line">    doLast&#123;</div><div class="line"></div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gradle内置为我们生成了很多task类型，比如Copy，Delete，可以点击<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="external">链接</a> 查看gradle内置的task类型列表，如果创建task时没有指定type，则他默认是DefaultTask类型。我们还可以创建自己的task类型，我们在稍后就会讲到。</p>
<p>我们还可以可以指定task之间的依赖关系, 通过dependsOn, mustRunAfter, shouldRunAfter来指定。 还可以指定task的分组group， 如果不指定，将会出现在other里面。</p>
<h2 id="自定义Gradle插件"><a href="#自定义Gradle插件" class="headerlink" title="自定义Gradle插件"></a>自定义Gradle插件</h2><p>我们先来看看gradle默认会生成哪些task，我们从app中删除以下code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;</div><div class="line"></div><div class="line">android&#123;</div><div class="line">    ...</div><div class="line">&#125;  </div><div class="line">dependencies&#123;</div><div class="line">  ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次运行gradlew app:tasks 会发现</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1008428-c802ee323d9f09db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>只有9个task，而且全都出现在help分组中，很多task都不见了，很容易才想出， 这些task都是android application插件生成的。我们能使用Gradle构建Android 工程，一切都基于这个插件。这个插件从android这个扩展中读取了我们的配置，生成了一些列构建android 所需要的任务。</p>
<p>如果我们想生成自己的Task，执行额外的任务呢？</p>
<p>我们需要扩展，首先我们需要扩展任务的类型，其次我们需要编写我们自己的插件，这两者并不是紧密联系的，有时候我们编写插件的时候，也许并不需要扩展任务类型，有时候我们并不需要编写额外的插件，只需要新写一种任务类型就能达到我们的目的。但大部分时候，这两者我们都需要，我们还需要实现我们自己的Extension，有了Extension我们就能从build.gradle脚本中读取我们需要的属性。因此我们需要做的事情是:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1008428-b76427ca3b274db9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对Gradle进行拓展"></p>
<p>接下我们看看怎么利用AndroidStudio编写我们自己的Gradle插件。AS默认不会为我们生成Groovy插件项目的结构，我们需要自己构建出来。首先新建一个Android Project， 在app subProject中src/main/下新建groovy和resources目录，删除其他目录，并修改build.gradle文件，像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;groovy&apos;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile gradleApi()</div><div class="line">    compile localGroovy()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在groovy木下新建HelloPlugin.groovy文件在resources目录下新建path:<br>META-INF/gradle-plugins/com.junli.HelloPlugin.properties,最终目录结构看起来就像这样：<br><img src="http://upload-images.jianshu.io/upload_images/1008428-0d219a600c8bb45d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gradle插件项目结构"><br>这里的com.junli.HelloPlugin最终会出现在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.junli.HelloPlugin&apos;</div></pre></td></tr></table></figure>
<p>我们开始编写HelloPlugin.groovy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package com.junli</div><div class="line"></div><div class="line">import org.gradle.api.Plugin</div><div class="line">import org.gradle.api.Project</div><div class="line"></div><div class="line">class HelloPlugin implements Plugin&lt;Project&gt;</div><div class="line">&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void apply(Project project) &#123;</div><div class="line">        project.task(&apos;helloPluginTask&apos;) &#123;</div><div class="line">            group &apos;junli&apos;</div><div class="line">            doLast &#123;</div><div class="line">                println &apos;hell i am a task in plugin&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们定义了一个类HelloPlugin，让其继承自gradle api中的Plugin<project> ，实现了apply接口函数，apply函数会在build.gradle中调用<strong>apply plugin: ‘xxx’</strong>时调用，我们的HelloPlugin插件的实现很简单，我们在project中创建了一个名叫helloPluginTask的task，分组为junli， action为打印一串字符串.</project></p>
<p>为了插件能成功apply, 我们还需要在META-INF/gradle-plugins/com.junli.helloPlugin.properties中写入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation-class=com.junli.HelloPlugin</div></pre></td></tr></table></figure></p>
<p>这句话指定了插件类的位置。</p>
<p>我们如何将其apply到自己的工程中去呢?，首先我们必须说明的是，插件可以以三种形式存在:</p>
<ol>
<li><p>在我们构建项目的build.gradle脚本中直接编写</p>
</li>
<li><p>在我们构建项目的<strong>rootProjectDir/buildSrc/src/main/groovy</strong> 目录下</p>
</li>
<li><p>以单独的project存在</p>
</li>
</ol>
<p>在这里我们采用的是第三种形式，这种形式的好处在于可以将插件打包发布，并很好的分享给使用者。</p>
<p>OK，那我们改如何分享呢？，我们可以先来学习如何在发布到本地，这样我们机器上的其他工程就能在指定目录下找到我们的插件。</p>
<p>要将插件发布，我们需要利用maven-publish插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;maven-publish&apos;</div><div class="line"></div><div class="line">publishing&#123;</div><div class="line">    publications &#123;</div><div class="line">        mavenJava(MavenPublication) &#123;</div><div class="line">            from components.java</div><div class="line"></div><div class="line">            groupId &apos;com.junli&apos;</div><div class="line">            artifactId &apos;helloPlugin&apos;</div><div class="line">            version &apos;0.1&apos;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    repositories&#123;</div><div class="line">        maven &#123;</div><div class="line">            // change to point to your repo, e.g. http://my.org/repo</div><div class="line">            url &quot;../repo&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>应用了插件maven-publish后，我们事先extension publishing，并在publications下添加我们需要发布的配置，这里我们添加了一个mavenJava，这个名字可以随意命名。其他配置还有</p>
<ul>
<li>from 指定需要发布的组件，目前仅有两种java 和 web</li>
<li><p>groupId、artifactId、version,这三者组成了插件使用者在声明依赖时的完整语句   <strong>groupId:artifactId:version</strong></p>
</li>
<li><p>默认打包时只会包含编译过的jar包，我们还可以将源代码和javadoc打包发布，可以通过artifact指定:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">task javadocJar(type: Jar, dependsOn: groovydoc) &#123;</div><div class="line">    classifier = &apos;javadoc&apos;</div><div class="line">    from &quot;$&#123;buildDir&#125;/javadoc&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">task sourcesJar(type: Jar) &#123;</div><div class="line">    from sourceSets.main.allSource</div><div class="line">    classifier = &apos;sources&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">mavenJava(MavenPublication) &#123;</div><div class="line">    from components.java</div><div class="line"></div><div class="line">     artifact sourcesJar</div><div class="line">     artifact javadocJar</div><div class="line"></div><div class="line">    groupId &apos;com.junli&apos;</div><div class="line">    artifactId &apos;helloPlugin&apos;</div><div class="line">    version &apos;0.1&apos;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们运行gradlew app:tasks就可以看到创建了如下tasks:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1008428-0ef91ed30f866359.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="publishing tasks"></p>
<p>有两种publish任务，publish 和 publishToMavenLocal， </p>
<p>publish任务依赖于所有的mavenPublication的generatePomFileFor任务和publishxxxPublicationToMavenRepository，意思是将所有的mavenPublication发布到指定的repository，</p>
<p>publishToMavenLocal依赖于所有的mavenPublication的generatePomFileFor和publishxxxTomavenLocal任务，意思是讲所有的mavenPublication发布到本地的m2 repository。</p>
<p>我们运行</p>
<blockquote>
<p>gradlew app:publish</p>
</blockquote>
<p>我们会在rootProjectDir的repo目录下看到我们生成的repo：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1008428-58c6ce9d308834a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地maven repo"></p>
<p>我们看到了目录结构为 groupId/artifactId/version， 每个版本下面有我们打包生成的jar包，每个jar包的校验文件(md5和sha1)，以及pom文件。pom文件是一个xml结构的文件，用来描述maven项目：包括配置文件；开发者需要遵循的规则，缺陷管理系统，组织和licenses，项目的url，项目的依赖性，以及其他所有的项目相关因素。</p>
<p>####应用插件</p>
<p>我们改如何应用插件呢？因为我们在插件已经publish到本地的目录中，因此我们可以在本地直接使用，我们在项目先新建一个子项目MyLibrary，为了使用插件我们需要修改build.gradle文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.junli.HelloPlugin&apos; //应用插件</div><div class="line"></div><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        maven &#123;</div><div class="line">            url uri(&apos;../repo&apos;) //插件所在的目录</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dependencies &#123;</div><div class="line">        classpath &apos;com.junli:helloPlugin:0.1&apos; //添加依赖</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先添加依赖，依赖寻找的repo需要添加我们之前发布的目录，然后应用插件.</p>
<p>我们运行graldew mylibrary:tasks可以看到mylibrary项目中生成了一个新的task:</p>
<blockquote>
<p> Junli tasks</p>
<pre><code>helloPluginTask
</code></pre></blockquote>
<p>处与junli分组下<br>运行任务打印出 </p>
<blockquote>
<p>hell i am a task in plugin</p>
</blockquote>
<p>通过这样一个简单的例子，我们了解了如何编写插件和应用插件，接下来我们通过添加Extension和Task来让我们的插件变得更强大</p>
<p>###Extension<br>我们在HelloPlugin同级目录下新建文件PersonExt.groovy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class PersonExt &#123;</div><div class="line"></div><div class="line">	String name;</div><div class="line"></div><div class="line">	int age;</div><div class="line"></div><div class="line">	boolean boy;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;I am $name, $age years old, &quot; + (boy?&quot;I am a boy&quot;:&quot;I am a gril&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并修改HelloPlugin的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class HelloPlugin implements Plugin&lt;Project&gt;</div><div class="line">&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void apply(Project project) &#123;</div><div class="line">        project.extensions.add(&quot;personExt&quot;, PersonExt)</div><div class="line"></div><div class="line">        project.task(&apos;printPerson&apos;) &#123;</div><div class="line">            group &apos;junli&apos;</div><div class="line"></div><div class="line">            doLast&#123;</div><div class="line">                PersonExt ext = project.personExt</div><div class="line"></div><div class="line">                println ext</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们对project添加了一个extension，这样子，我们可以在使用插件的地方，实现这个extension，我们能够在插件apply的时候拿到这个extension, 读取extension中的属性，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">personExt&#123;</div><div class="line">    name  &apos;Tom&apos;</div><div class="line">    age  10</div><div class="line">    boy   false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再次运行我们的任务</p>
<blockquote>
<p>gradlew mylibrary:printPerson</p>
<p>I am Tom, 10 years old, I am a gril</p>
</blockquote>
<p>你可以看到这里的name和age 都没有使用=号进行复制，就是利用了grooy特性，它实际上是调用了setName方法，并且省略了方法调用的括号。</p>
<p>如果我们想读取一个列表，这个列表的长度不定呢？</p>
<p>我们需要使用<strong>NamedDomainObjectContainer</strong>,我们后面都简称NDOC 这是一个容纳object的容器，它的特点是它的内部使用SortedSet实现的，内部对象的name是unique的，而且是按name进行排序的。通常创建NDOC的方法就是调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; [NamedDomainObjectContainer] &lt;T&gt; container(Class&lt;T&gt; type)</div></pre></td></tr></table></figure></p>
<p>这里type有一个要求：必须有一个public的构造函数，接受string作为一个参数，必须有一个叫做name 的property。</p>
<p>接下来我们看如何获取一个person的列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class HelloPlugin implements Plugin&lt;Project&gt;</div><div class="line">&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void apply(Project project) &#123;</div><div class="line">        //创建一个容器</div><div class="line">        NamedDomainObjectContainer&lt;Person&gt; persons = project.container(Person)</div><div class="line">         //将容器添加为extension</div><div class="line">        project.extensions.add(&apos;team&apos;, persons)</div><div class="line"></div><div class="line">        def task = project.task(&apos;showTeam&apos;)&#123;</div><div class="line">            group &apos;junli&apos;</div><div class="line">            doLast &#123;</div><div class="line">                def team1 = project.extensions.getByName(&apos;team&apos;)</div><div class="line"></div><div class="line"></div><div class="line">                println team1</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样我们只需要修改extension为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">team&#123;</div><div class="line">    John&#123;</div><div class="line">        age = 10</div><div class="line">        boy = false</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Tom&#123;</div><div class="line">        age = 20</div><div class="line">        boy = false</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后通过println 我们可以看到我们这个容器中的内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[I am John, 10 years old, I am a gril, I am Tom, 20 years old, I am a gril]</div></pre></td></tr></table></figure></p>
<p>我们了解了如何通过extension读取列表，接下来，我们可以混合列表和单个属性，就像<strong>android{…}</strong>一样</p>
<p>我们新建一个类Team</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//Team.groovy</div><div class="line">class Team &#123;</div><div class="line"></div><div class="line">    NamedDomainObjectContainer&lt;Person&gt;  persons;</div><div class="line"></div><div class="line">    String name;</div><div class="line"></div><div class="line">    int count;</div><div class="line"></div><div class="line">    public Team(NamedDomainObjectContainer&lt;Person&gt; persons)&#123;</div><div class="line">        this.persons = persons;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //persons函数，允许我们通过配置传入闭包，来给persons容器添加对象</div><div class="line">    def persons(Closure closure)&#123;</div><div class="line">        persons.configure(closure)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    String toString() &#123;</div><div class="line">        return &quot;This is a team, name: $name, count: $count&quot; + &quot; persons: &quot;+ persons</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的persons(closure)函数是必须的，只有实现了这个函数，Gradle在解析team的extension，遇到persons配置时，才能通过调用函数，调用    NamedDomainObjectContainer的configure方法，往里面添加对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class HelloPlugin implements Plugin&lt;Project&gt;</div><div class="line">&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    void apply(Project project) &#123;</div><div class="line"></div><div class="line">        NamedDomainObjectContainer&lt;Person&gt; persons = project.container(Person)</div><div class="line"></div><div class="line">        Team team = new Team(persons)</div><div class="line"></div><div class="line">        project.extensions.add(&apos;team&apos;, team)</div><div class="line"></div><div class="line">        def task = project.task(&apos;showTeam&apos;)&#123;</div><div class="line">            group &apos;junli&apos;</div><div class="line">            doLast &#123;</div><div class="line">                def team1 = project.extensions.getByName(&apos;team&apos;)</div><div class="line"></div><div class="line"></div><div class="line">                println team1</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">team&#123;</div><div class="line">    name = &apos;GSW&apos;</div><div class="line">    count = 20</div><div class="line">    persons&#123;</div><div class="line">        John&#123;</div><div class="line">            age = 10</div><div class="line">            boy = false</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Tom&#123;</div><div class="line">            age = 20</div><div class="line">            boy = false</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行任务showTeam输出为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">This is a team, name: GSW, count: 20 persons: [I am John, 10 years old, I am a gril, I am Tom, 20 years old, I am a gril]</div></pre></td></tr></table></figure></p>
<p>这样我们就通过一个简单的例子就熟悉了Gradle插件的编写规则，而且通过对groovy语法的了解，让我们对gradle的DSL不再陌生，好了这是第一篇我们要讲的内容，下一篇我会带来自定义Task，复杂的plugin，上传jcenter等内容，小伙伴记得关注哦。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/09/06/custom-gradle-plugin-1/" data-id="cisr685k50002wjkwx9eedy31" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Gradle/">Gradle</a><a href="/tags/Android/">Android</a></div><div class="post-nav"><a href="/2016/09/06/android-package-essentials/" class="pre">Android打包系列-基础知识</a></div><div data-thread-key="2016/09/06/custom-gradle-plugin-1/" data-title="Gradle自定义Plugin(上)" data-url="http://yoursite.com/2016/09/06/custom-gradle-plugin-1/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/09/06/custom-gradle-plugin-1/" data-title="Gradle自定义Plugin(上)" data-url="http://yoursite.com/2016/09/06/custom-gradle-plugin-1/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/android-package-essentials/">Android打包系列-基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/custom-gradle-plugin-1/">Gradle自定义Plugin(上)</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'qinjunli123'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>