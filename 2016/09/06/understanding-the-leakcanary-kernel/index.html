<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>LeakCanary 内存泄露监测原理研究 | Hexo</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LeakCanary 内存泄露监测原理研究</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LeakCanary 内存泄露监测原理研究</h1><div class="post-meta">Sep 6, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/09/06/understanding-the-leakcanary-kernel/" href="/2016/09/06/understanding-the-leakcanary-kernel/#comments" class="ds-thread-count"></a><div class="post-content"><p>“Read the fucking source code” – linus一句名言体现出了阅读源码的重要性，学习别人得代码是提升自己的重要途径。最近用到了LeakCanary，顺便看一下其代码，学习一下。<br>LeakCanary是安卓中用来检测内存泄露的小工具，它能帮助我们提早发现代码中隐藏的bug, 降低应用中内存泄露以及OOM产生的概率。</p>
<p>废话不多说，关于LeakCanary的使用方法，其实很简单，如果我们只想检测Activity的内存泄露，而且只想使用其默认的报告方式，我们只需要在Application中加一行代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LeakCanary.install(this);</div></pre></td></tr></table></figure>
<p>那我们今天阅读源码的切入点，就从这个静态方法开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">  * Creates a &#123;@link RefWatcher&#125; that works out of the box, and starts watching activity</div><div class="line">  * references (on ICS+).</div><div class="line">  */</div><div class="line"> public static RefWatcher install(Application application) &#123;</div><div class="line">   return install(application, DisplayLeakService.class,</div><div class="line">       AndroidExcludedRefs.createAppDefaults().build());</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这个函数内部直接调用了另外一个重载的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * Creates a &#123;@link RefWatcher&#125; that reports results to the provided service, and starts watching</div><div class="line">   * activity references (on ICS+).</div><div class="line">   */</div><div class="line">  public static RefWatcher install(Application application,</div><div class="line">      Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass,</div><div class="line">      ExcludedRefs excludedRefs) &#123;</div><div class="line">    //判断是否在Analyzer进程里</div><div class="line">    if (isInAnalyzerProcess(application)) &#123;</div><div class="line">      return RefWatcher.DISABLED;</div><div class="line">    &#125;</div><div class="line">    enableDisplayLeakActivity(application);</div><div class="line">    HeapDump.Listener heapDumpListener =</div><div class="line">        new ServiceHeapDumpListener(application, listenerServiceClass);</div><div class="line">    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);</div><div class="line">    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);</div><div class="line">    return refWatcher;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>因为leakcanay会开启一个远程service用来分析每次产生的内存泄露，而安卓的应用每次开启进程都会调用Applicaiton的onCreate方法，因此我们有必要预先判断此次Application启动是不是在analyze service启动时，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public static boolean isInServiceProcess(Context context, Class&lt;? extends Service&gt; serviceClass) &#123;</div><div class="line">    PackageManager packageManager = context.getPackageManager();</div><div class="line">    PackageInfo packageInfo;</div><div class="line">    try &#123;</div><div class="line">      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">      Log.e(&quot;AndroidUtils&quot;, &quot;Could not get package info for &quot; + context.getPackageName(), e);</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line">    String mainProcess = packageInfo.applicationInfo.processName;</div><div class="line"></div><div class="line">    ComponentName component = new ComponentName(context, serviceClass);</div><div class="line">    ServiceInfo serviceInfo;</div><div class="line">    try &#123;</div><div class="line">      serviceInfo = packageManager.getServiceInfo(component, 0);</div><div class="line">    &#125; catch (PackageManager.NameNotFoundException ignored) &#123;</div><div class="line">      // Service is disabled.</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (serviceInfo.processName.equals(mainProcess)) &#123;</div><div class="line">      Log.e(&quot;AndroidUtils&quot;,</div><div class="line">          &quot;Did not expect service &quot; + serviceClass + &quot; to run in main process &quot; + mainProcess);</div><div class="line">      // Technically we are in the service process, but we&apos;re not in the service dedicated process.</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //查找当前进程名</div><div class="line">    int myPid = android.os.Process.myPid();</div><div class="line">    ActivityManager activityManager =</div><div class="line">        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">    ActivityManager.RunningAppProcessInfo myProcess = null;</div><div class="line">    for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) &#123;</div><div class="line">      if (process.pid == myPid) &#123;</div><div class="line">        myProcess = process;</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    if (myProcess == null) &#123;</div><div class="line">      Log.e(&quot;AndroidUtils&quot;, &quot;Could not find running process for &quot; + myPid);</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return myProcess.processName.equals(serviceInfo.processName);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>判断Application是否是在service进程里面启动，最直接的方法就是判断当前进程名和service所属的进程是否相同。当前进程名的获取方式是使用ActivityManager的getRunningAppProcessInfo方法，找到进程pid与当前进程pid相同的进程，然后从中拿到processName. service所属进程名。获取service应处进程的方法是用PackageManager的getPackageInfo方法。</p>
<p>###RefWatcher<br>ReftWatcher是leakcancay检测内存泄露的发起点。使用方法为，在对象生命周期即将结束的时候，调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RefWatcher.watch(Object object)</div></pre></td></tr></table></figure></p>
<p>为了达到检测内存泄露的目的，RefWatcher需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private final Executor watchExecutor;</div><div class="line">private final DebuggerControl debuggerControl;</div><div class="line">private final GcTrigger gcTrigger;</div><div class="line">private final HeapDumper heapDumper;</div><div class="line">private final Set&lt;String&gt; retainedKeys;</div><div class="line">private final ReferenceQueue&lt;Object&gt; queue;</div><div class="line">private final HeapDump.Listener heapdumpListener;</div><div class="line">private final ExcludedRefs excludedRefs;</div></pre></td></tr></table></figure></p>
<ul>
<li>watchExecutor: 执行内存泄露检测的executor</li>
<li>debuggerControl ：用于查询是否正在调试中，调试中不会执行内存泄露检测</li>
<li>queue ： 用于判断弱引用所持有的对象是否已被GC。</li>
<li>gcTrigger： 用于在判断内存泄露之前，再给一次GC的机会</li>
<li>headDumper: 用于在产生内存泄露室执行dump 内存heap</li>
<li>heapdumpListener: 用于分析前面产生的dump文件，找到内存泄露的原因</li>
<li>excludedRefs: 用于排除某些系统bug导致的内存泄露</li>
<li>retainedKeys： 持有那些呆检测以及产生内存泄露的引用的key。</li>
</ul>
<p>接下来，我们来看看watch函数背后是如何利用这些工具，生成内存泄露分析报告的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public void watch(Object watchedReference, String referenceName) &#123;</div><div class="line">    checkNotNull(watchedReference, &quot;watchedReference&quot;);</div><div class="line">    checkNotNull(referenceName, &quot;referenceName&quot;);</div><div class="line">    //如果处于debug模式，则直接返回</div><div class="line">    if (debuggerControl.isDebuggerAttached()) &#123;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    //记住开始观测的时间</div><div class="line">    final long watchStartNanoTime = System.nanoTime();</div><div class="line">    //生成一个随机的key，并加入set中</div><div class="line">    String key = UUID.randomUUID().toString();</div><div class="line">    retainedKeys.add(key);</div><div class="line">    //生成一个KeyedWeakReference</div><div class="line">    final KeyedWeakReference reference =</div><div class="line">        new KeyedWeakReference(watchedReference, key, referenceName, queue);</div><div class="line">    //调用watchExecutor，执行内存泄露的检测</div><div class="line">    watchExecutor.execute(new Runnable() &#123;</div><div class="line">      @Override public void run() &#123;</div><div class="line">        ensureGone(reference, watchStartNanoTime);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>所以最后的核心函数是在ensureGone这个runnable里面。要理解其工作原理，就得从keyedWeakReference说起</p>
<p>###WeakReference与ReferenceQueue<br>从watch函数中，可以看到，每次检测对象内存是否泄露时，我们都会生成一个KeyedReferenceQueue，这个类其实就是一个WeakReference，只不过其额外附带了一个key和一个name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">final class KeyedWeakReference extends WeakReference&lt;Object&gt; &#123;</div><div class="line">  public final String key;</div><div class="line">  public final String name;</div><div class="line"></div><div class="line">  KeyedWeakReference(Object referent, String key, String name,</div><div class="line">      ReferenceQueue&lt;Object&gt; referenceQueue) &#123;</div><div class="line">    super(checkNotNull(referent, &quot;referent&quot;), checkNotNull(referenceQueue, &quot;referenceQueue&quot;));</div><div class="line">    this.key = checkNotNull(key, &quot;key&quot;);</div><div class="line">    this.name = checkNotNull(name, &quot;name&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在构造时我们需要传入一个ReferenceQueue，这个ReferenceQueue是直接传入了WeakReference中，关于这个类，有兴趣的可以直接看Reference的源码。我们这里需要知道的是，每次WeakReference所指向的对象被GC后，这个弱引用都会被放入这个与之相关联的ReferenceQueue队列中。</p>
<p>我们这里可以贴下其核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">private static class ReferenceHandler extends Thread &#123;</div><div class="line"></div><div class="line">        ReferenceHandler(ThreadGroup g, String name) &#123;</div><div class="line">            super(g, name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">                Reference&lt;Object&gt; r;</div><div class="line">                synchronized (lock) &#123;</div><div class="line">                    if (pending != null) &#123;</div><div class="line">                        r = pending;</div><div class="line">                        pending = r.discovered;</div><div class="line">                        r.discovered = null;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        //....</div><div class="line">                        try &#123;</div><div class="line">                            try &#123;</div><div class="line">                                lock.wait();</div><div class="line">                            &#125; catch (OutOfMemoryError x) &#123; &#125;</div><div class="line">                        &#125; catch (InterruptedException x) &#123; &#125;</div><div class="line">                        continue;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Fast path for cleaners</div><div class="line">                if (r instanceof Cleaner) &#123;</div><div class="line">                    ((Cleaner)r).clean();</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ReferenceQueue&lt;Object&gt; q = r.queue;</div><div class="line">                if (q != ReferenceQueue.NULL) q.enqueue(r);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        ThreadGroup tg = Thread.currentThread().getThreadGroup();</div><div class="line">        for (ThreadGroup tgn = tg;</div><div class="line">             tgn != null;</div><div class="line">             tg = tgn, tgn = tg.getParent());</div><div class="line">        Thread handler = new ReferenceHandler(tg, &quot;Reference Handler&quot;);</div><div class="line">        /* If there were a special system-only priority greater than</div><div class="line">         * MAX_PRIORITY, it would be used here</div><div class="line">         */</div><div class="line">        handler.setPriority(Thread.MAX_PRIORITY);</div><div class="line">        handler.setDaemon(true);</div><div class="line">        handler.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在reference类加载的时候，java虚拟机会创建一个最大优先级的后台线程，这个线程的工作原理就是不断检测pending是否为null，如果不为null，就将其放入ReferenceQueue中，pending不为null的情况就是，引用所指向的对象已被GC，变为不可达。</p>
<p>那么只要我们在构造弱引用的时候指定了ReferenceQueue，每当弱引用所指向的对象被内存回收的时候，我们就可以在queue中找到这个引用。如果我们期望一个对象被回收，那如果在接下来的预期时间之后，我们发现它依然没有出现在ReferenceQueue中，那就可以判定它的内存泄露了。LeakCanary检测内存泄露的核心原理就在这里。</p>
<p>其实Java里面的WeakHashMap里也用到了这种方法，来判断hash表里的某个键值是否还有效。在构造WeakReference的时候给其指定了ReferenceQueue.</p>
<p>###监测时机<br>什么时候去检测能判定内存泄露呢？这个可以看AndroidWatchExecutor的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public final class AndroidWatchExecutor implements Executor &#123;</div><div class="line"></div><div class="line">    //....</div><div class="line">    </div><div class="line">    private void executeDelayedAfterIdleUnsafe(final Runnable runnable) &#123;</div><div class="line">        // This needs to be called from the main thread.</div><div class="line">        Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123;</div><div class="line">          @Override public boolean queueIdle() &#123;</div><div class="line">            backgroundHandler.postDelayed(runnable, DELAY_MILLIS);</div><div class="line">            return false;</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这里又看到一个比较少的用法，<strong>IdleHandler</strong>，IdleHandler的原理就是在messageQueue因为空闲等待消息时给使用者一个hook。那AndroidWatchExecutor会在主线程空闲的时候，派发一个后台任务，这个后台任务会在DELAY_MILLIS时间之后执行。LeakCanary设置的是5秒。</p>
<p>###二次确认保证内存泄露准确性<br>为了避免因为gc不及时带来的误判，leakcanay会进行二次确认进行保证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) &#123;</div><div class="line">    long gcStartNanoTime = System.nanoTime();</div><div class="line">    //计算从调用watch到进行检测的时间段</div><div class="line">    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</div><div class="line">    //根据queue移除已被GC的对象的弱引用</div><div class="line">    removeWeaklyReachableReferences();</div><div class="line">    //如果内存已被回收或者处于debug模式，直接返回</div><div class="line">    if (gone(reference) || debuggerControl.isDebuggerAttached()) &#123;</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line">    //如果内存依旧没被释放，则再给一次gc的机会</div><div class="line">    gcTrigger.runGc();</div><div class="line">    //再次移除</div><div class="line">    removeWeaklyReachableReferences();</div><div class="line">    if (!gone(reference)) &#123;</div><div class="line">      //走到这里，认为内存确实泄露了</div><div class="line">      long startDumpHeap = System.nanoTime();</div><div class="line">      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</div><div class="line">      //dump出heap报告</div><div class="line">      File heapDumpFile = heapDumper.dumpHeap();</div><div class="line"></div><div class="line">      if (heapDumpFile == HeapDumper.NO_DUMP) &#123;</div><div class="line">        // Could not dump the heap, abort.</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line">      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</div><div class="line">      heapdumpListener.analyze(</div><div class="line">          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,</div><div class="line">              gcDurationMs, heapDumpDurationMs));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private boolean gone(KeyedWeakReference reference) &#123;</div><div class="line">    return !retainedKeys.contains(reference.key);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private void removeWeaklyReachableReferences() &#123;</div><div class="line">    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly</div><div class="line">    // reachable. This is before finalization or garbage collection has actually happened.</div><div class="line">    KeyedWeakReference ref;</div><div class="line">    while ((ref = (KeyedWeakReference) queue.poll()) != null) &#123;</div><div class="line">      retainedKeys.remove(ref.key);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>###Dump Heap<br>监测到内存泄露后，首先做的就是dump出当前的heap，默认的AndroidHeapDumper调用的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Debug.dumpHprofData(filePath);</div></pre></td></tr></table></figure></p>
<p>到处当前内存的hprof分析文件，一般我们在DeviceMonitor中也可以dump出hprof文件，然后将其从dalvik格式转成标准jvm格式，然后使用MAT进行分析。</p>
<p>那么LeakCanary是如何分析内存泄露的呢？</p>
<p>###HaHa<br>LeakCanary 分析内存泄露用到了一个和Mat类似的工具叫做<a href="https://github.com/square/haha" target="_blank" rel="external">HaHa</a>，使用HaHa的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) &#123;</div><div class="line">    long analysisStartNanoTime = System.nanoTime();</div><div class="line"></div><div class="line">    if (!heapDumpFile.exists()) &#123;</div><div class="line">      Exception exception = new IllegalArgumentException(&quot;File does not exist: &quot; + heapDumpFile);</div><div class="line">      return failure(exception, since(analysisStartNanoTime));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);</div><div class="line">      HprofParser parser = new HprofParser(buffer);</div><div class="line">      Snapshot snapshot = parser.parse();</div><div class="line"></div><div class="line">      Instance leakingRef = findLeakingReference(referenceKey, snapshot);</div><div class="line"></div><div class="line">      // False alarm, weak reference was cleared in between key check and heap dump.</div><div class="line">      if (leakingRef == null) &#123;</div><div class="line">        return noLeak(since(analysisStartNanoTime));</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);</div><div class="line">    &#125; catch (Throwable e) &#123;</div><div class="line">      return failure(e, since(analysisStartNanoTime));</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>关于HaHa的原理，感兴趣的同学可以深究，这里就不深入介绍了。</p>
<p>返回的ActivityResult对象中包含了对象到GC root的最短路径。LeakCanary在dump出hprof文件后，会启动一个IntentService进行分析：HeapAnalyzerService在分析出结果之后会启动DisplayLeakService用来发起Notification 以及将结果记录下来写在文件里面。以后每次启动LeakAnalyzerActivity就从文件里读取历史结果。</p>
<p>###ExcludedRef<br>由于某些系统的bug，以及某些厂商rom的bug，Activity在finish之后仍然会被某些系统组件给hold住。LeakCanary列出了一些很常见的，比如三星的手机activity会被audioManager给hold住，试了一下huawei的系统貌似也会出现，还有比如activity中如果有会获取键盘焦点的view，在activity finish之后view会被InputMethodManager给hold住，因为view会持有activity 造成activity泄漏，除非有新的view获取键盘焦点。</p>
<p>LeakCanary中有一个AndroidExcludedRefs枚举类，其中枚举了很多特定版本系统issue引起的内存泄漏，因为这种问题 不是开发者导致的，因此HeapAnalyzerService在分析内存泄露时，会将这些GC Root排除在外。而且每个ExcludedRef通常都跟特定厂商或者Android版本有关，这些枚举类都加了一个适用条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">AndroidExcludedRefs(boolean applies) &#123;  this.applies = applies;&#125;</div><div class="line"></div><div class="line"></div><div class="line">   AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) &amp;&amp; SDK_INT == KITKAT) &#123;</div><div class="line">    @Override void add(ExcludedRefs.Builder excluded) &#123;</div><div class="line">      // Samsung added a static mContext_static field to AudioManager, holds a reference to the</div><div class="line">      // activity.</div><div class="line">      // Observed here: https://github.com/square/leakcanary/issues/32</div><div class="line">      excluded.staticField(&quot;android.media.AudioManager&quot;, &quot;mContext_static&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p>比如上面这个AudioManager引起的问题，只有在Build中的MANUFACTURER表明是三星以及sdk版本是KITKAT（4.4, 19)时才适用。</p>
<p>###手动释放资源<br>然后并不是leakCanary不报错我们就不用管，activity内存泄露了，大部分情况下没多大事，但是有些占用内存很多的页面，比如图库，webview页面，因为acitivity不能回收，它所指向的view以及view下面的bitmap都不能被回收，这是会造成很不好的后果的，很可能会导致OOM，因此我们需要手动在Activity结束时回收资源。</p>
<p>###Under 4.0 &amp; Fragment<br>LeakCanary只支持4.0以上，原因是其中在watch 每个Activity时适用了Application的<strong>registerActivityLifecycleCallback</strong>函数，这个函数只在4.0上才支持，但是在4.0以下也是可以用的，可以在Application中将返回的RefWatcher存下来，然后在基类Activity的onDestroy函数中调用。</p>
<p>同理，如果我们想检测Fragment的内存的话，我们也阔以在Fragment的onDestroy中watch它。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/09/06/understanding-the-leakcanary-kernel/" data-id="cisr6bjub0003xjkw5p4fo9lz" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/Tools/">Tools</a></div><div class="post-nav"><a href="/2016/09/06/deep-into-android-fragment/" class="next">从源码角度剖析Fragment核心知识点</a></div><div data-thread-key="2016/09/06/understanding-the-leakcanary-kernel/" data-title="LeakCanary 内存泄露监测原理研究" data-url="http://yoursite.com/2016/09/06/understanding-the-leakcanary-kernel/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/09/06/understanding-the-leakcanary-kernel/" data-title="LeakCanary 内存泄露监测原理研究" data-url="http://yoursite.com/2016/09/06/understanding-the-leakcanary-kernel/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/understanding-the-leakcanary-kernel/">LeakCanary 内存泄露监测原理研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/deep-into-android-fragment/">从源码角度剖析Fragment核心知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/android-package-essentials/">Android打包系列-基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/custom-gradle-plugin-1/">Gradle自定义Plugin(上)</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'qinjunli123'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>